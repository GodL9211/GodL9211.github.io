<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="https://vuepress-theme-hope-docs-demo.netlify.app/rss.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://vuepress-theme-hope-docs-demo.netlify.app/rss.xml" rel="self" type="application/rss+xml"/>
    <title>暴走の海鸽</title>
    <link>https://vuepress-theme-hope-docs-demo.netlify.app/</link>
    <description>暴走の海鸽</description>
    <language>zh-CN</language>
    <pubDate>Thu, 07 Dec 2023 10:03:18 GMT</pubDate>
    <lastBuildDate>Thu, 07 Dec 2023 10:03:18 GMT</lastBuildDate>
    <generator>vuepress-plugin-feed2</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <category>数据库</category>
    <item>
      <title>MySQL索引详解</title>
      <link>https://vuepress-theme-hope-docs-demo.netlify.app/docs/interviews/mysql/mysql%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3.html</link>
      <guid>https://vuepress-theme-hope-docs-demo.netlify.app/docs/interviews/mysql/mysql%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3.html</guid>
      <source url="https://vuepress-theme-hope-docs-demo.netlify.app/rss.xml">MySQL索引详解</source>
      <description>文章来源： https://javaguide.cn/database/mysql/mysql-index.html  感谢WT-AHA (https://github.com/WT-AHA)对本文的完善，相关 PR：https://github.com/Snailclimb/JavaGuide/pull/1648 。 但凡经历过几场面试的小伙伴，应...</description>
      <category>数据库</category>
      <pubDate>Tue, 05 Dec 2023 10:37:11 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>文章来源： <a href="https://javaguide.cn/database/mysql/mysql-index.html" target="_blank" rel="noopener noreferrer">https://javaguide.cn/database/mysql/mysql-index.html</a><br>
感谢<a href="https://github.com/WT-AHA" target="_blank" rel="noopener noreferrer">WT-AHA</a>对本文的完善，相关 PR：<a href="https://github.com/Snailclimb/JavaGuide/pull/1648" target="_blank" rel="noopener noreferrer">https://github.com/Snailclimb/JavaGuide/pull/1648</a> 。</p>
</blockquote>
<p>但凡经历过几场面试的小伙伴，应该都清楚，数据库索引这个知识点在面试中出现的频率高到离谱。</p>
<p>除了对于准备面试来说非常重要之外，善用索引对 SQL 的性能提升非常明显，是一个性价比较高的 SQL 优化手段。</p>
<h2> 索引介绍</h2>
<p><strong>索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。</strong></p>
<p>索引的作用就相当于书的目录。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。</p>
<p>索引底层数据结构存在很多种类型，常见的索引结构有: B 树， B+树 和 Hash、红黑树。在 MySQL 中，无论是 Innodb 还是 MyIsam，都使用了 B+树作为索引结构。</p>
<h2> 索引的优缺点</h2>
<p><strong>优点</strong>：</p>
<ul>
<li>使用索引可以大大加快 数据的检索速度（大大减少检索的数据量）, 这也是创建索引的最主要的原因。</li>
<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li>
<li>索引需要使用物理文件存储，也会耗费一定空间。</li>
</ul>
<p>但是，<strong>使用索引一定能提高查询性能吗?</strong></p>
<p>大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。</p>
<h2> 索引底层数据结构选型</h2>
<h3> Hash 表</h3>
<p>哈希表是键值对的集合，通过键(key)即可快速取出对应的值(value)，因此哈希表可以快速检索数据（接近 O（1））。</p>
<p><strong>为何能够通过 key 快速取出 value 呢？</strong> 原因在于 <strong>哈希算法</strong>（也叫散列算法）。通过哈希算法，我们可以快速找到 key 对应的 index，找到了 index 也就找到了对应的 value。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><figcaption></figcaption></figure>
<p>但是！哈希算法有个 <strong>Hash 冲突</strong> 问题，也就是说多个不同的 key 最后得到的 index 相同。通常情况下，我们常用的解决办法是 <strong>链地址法</strong>。链地址法就是将哈希冲突数据存放在链表中。就比如 JDK1.8 之前 <code>HashMap</code> 就是通过链地址法来解决哈希冲突的。不过，JDK1.8 以后<code>HashMap</code>为了减少链表过长的时候搜索时间过长引入了红黑树。</p>
<figure><figcaption></figcaption></figure>
<p>为了减少 Hash 冲突的发生，一个好的哈希函数应该“均匀地”将数据分布在整个可能的哈希值集合中。</p>
<p>MySQL 的 InnoDB 存储引擎不直接支持常规的哈希索引，但是，InnoDB 存储引擎中存在一种特殊的“自适应哈希索引”（Adaptive Hash Index），自适应哈希索引并不是传统意义上的纯哈希索引，而是结合了 B+Tree 和哈希索引的特点，以便更好地适应实际应用中的数据访问模式和性能需求。自适应哈希索引的每个哈希桶实际上是一个小型的 B+Tree 结构。这个 B+Tree 结构可以存储多个键值对，而不仅仅是一个键。这有助于减少哈希冲突链的长度，提高了索引的效率。关于 Adaptive Hash Index 的详细介绍，可以查看 <a href="https://mp.weixin.qq.com/s/ra4v1XR5pzSWc-qtGO-dBg" target="_blank" rel="noopener noreferrer">MySQL 各种“Buffer”之 Adaptive Hash Index</a> 这篇文章。</p>
<p>既然哈希表这么快，<strong>为什么 MySQL 没有使用其作为索引的数据结构呢？</strong> 主要是因为 Hash 索引不支持顺序和范围查询。假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了。并且，每次 IO 只能取一个。</p>
<p>试想一种情况:</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在这种范围查询中，优势非常大，直接遍历比 500 小的叶子节点就够了。而 Hash 索引是根据 hash 算法来定位的，难不成还要把 1 - 499 的数据，每个都进行一次 hash 计算来定位吗?这就是 Hash 最大的缺点了。</p>
<h3> 二叉查找树(BST)</h3>
<p>二叉查找树（Binary Search Tree）是一种基于二叉树的数据结构，它具有以下特点：</p>
<ol>
<li>左子树所有节点的值均小于根节点的值。</li>
<li>右子树所有节点的值均大于根节点的值。</li>
<li>左右子树也分别为二叉查找树。</li>
</ol>
<p>当二叉查找树是平衡的时候，也就是树的每个节点的左右子树深度相差不超过 1 的时候，查询的时间复杂度为 O(log2(N))，具有比较高的效率。然而，当二叉查找树不平衡时，例如在最坏情况下（有序插入节点），树会退化成线性链表（也被称为斜树），导致查询效率急剧下降，时间复杂退化为 O（N）。</p>
<figure><figcaption>斜树</figcaption></figure>
<p>也就是说，<strong>二叉查找树的性能非常依赖于它的平衡程度，这就导致其不适合作为 MySQL 底层索引的数据结构。</strong></p>
<p>为了解决这个问题，并提高查询效率，人们发明了多种在二叉查找树基础上的改进型数据结构，如平衡二叉树、B-Tree、B+Tree 等。</p>
<h3> AVL 树</h3>
<p>AVL 树是计算机科学中最早被发明的自平衡二叉查找树，它的名称来自于发明者 G.M. Adelson-Velsky 和 E.M. Landis 的名字缩写。AVL 树的特点是保证任何节点的左右子树高度之差不超过 1，因此也被称为高度平衡二叉树，它的查找、插入和删除在平均和最坏情况下的时间复杂度都是 O(logn)。</p>
<figure><figcaption>AVL 树</figcaption></figure>
<p>AVL 树采用了旋转操作来保持平衡。主要有四种旋转操作：LL 旋转、RR 旋转、LR 旋转和 RL 旋转。其中 LL 旋转和 RR 旋转分别用于处理左左和右右失衡，而 LR 旋转和 RL 旋转则用于处理左右和右左失衡。</p>
<p>由于 AVL 树需要频繁地进行旋转操作来保持平衡，因此会有较大的计算开销进而降低了查询性能。并且， 在使用 AVL 树时，每个树节点仅存储一个数据，而每次进行磁盘 IO 时只能读取一个节点的数据，如果需要查询的数据分布在多个节点上，那么就需要进行多次磁盘 IO。 <strong>磁盘 IO 是一项耗时的操作，在设计数据库索引时，我们需要优先考虑如何最大限度地减少磁盘 IO 操作的次数。</strong></p>
<p>实际应用中，AVL 树使用的并不多。</p>
<h3> 红黑树</h3>
<p>红黑树是一种自平衡二叉查找树，通过在插入和删除节点时进行颜色变换和旋转操作，使得树始终保持平衡状态，它具有以下特点：</p>
<ol>
<li>每个节点非红即黑；</li>
<li>根节点总是黑色的；</li>
<li>每个叶子节点都是黑色的空节点（NIL 节点）；</li>
<li>如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；</li>
<li>从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。</li>
</ol>
<figure><figcaption>红黑树</figcaption></figure>
<p>和 AVL 树不同的是，红黑树并不追求严格的平衡，而是大致的平衡。正因如此，红黑树的查询效率稍有下降，因为红黑树的平衡性相对较弱，可能会导致树的高度较高，这可能会导致一些数据需要进行多次磁盘 IO 操作才能查询到，这也是 MySQL 没有选择红黑树的主要原因。也正因如此，红黑树的插入和删除操作效率大大提高了，因为红黑树在插入和删除节点时只需进行 O(1) 次数的旋转和变色操作，即可保持基本平衡状态，而不需要像 AVL 树一样进行 O(logn) 次数的旋转操作。</p>
<p><strong>红黑树的应用还是比较广泛的，TreeMap、TreeSet 以及 JDK1.8 的 HashMap 底层都用到了红黑树。对于数据在内存中的这种情况来说，红黑树的表现是非常优异的。</strong></p>
<h3> B 树&amp; B+树</h3>
<p>B 树也称 B-树,全称为 <strong>多路平衡查找树</strong> ，B+ 树是 B 树的一种变体。B 树和 B+树中的 B 是 <code>Balanced</code> （平衡）的意思。</p>
<p>目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构。</p>
<p><strong>B 树&amp; B+树两者有何异同呢？</strong></p>
<ul>
<li>B 树的所有节点既存放键(key) 也存放数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。</li>
<li>B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</li>
<li>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li>
<li>在 B 树中进行范围查询时，首先找到要查找的下限，然后对 B 树进行中序遍历，直到找到查找的上限；而 B+树的范围查询，只需要对链表进行遍历即可。</li>
</ul>
<p>综上，B+树与 B 树相比，具备更少的 IO 次数、更稳定的查询效率和更适于范围查询这些优势。</p>
<p>在 MySQL 中，MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是，两者的实现方式不太一样。（下面的内容整理自《Java 工程师修炼之道》）</p>
<blockquote>
<p>MyISAM 引擎中，B+Tree 叶节点的 data 域存放的是数据记录的地址。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“<strong>非聚簇索引（非聚集索引）</strong>”。</p>
<p>InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。这被称为“<strong>聚簇索引（聚集索引）</strong>”，而其余的索引都作为 <strong>辅助索引</strong> ，辅助索引的 data 域存储相应记录主键的值而不是地址，这也是和 MyISAM 不同的地方。在根据主索引搜索时，直接找到 key 所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</p>
</blockquote>
<h2> 索引类型总结</h2>
<p>按照数据结构维度划分：</p>
<ul>
<li>BTree 索引：MySQL 里默认和最常用的索引类型。只有叶子节点存储 value，非叶子节点只有指针和 key。存储引擎 MyISAM 和 InnoDB 实现 BTree 索引都是使用 B+Tree，但二者实现方式不一样（前面已经介绍了）。</li>
<li>哈希索引：类似键值对的形式，一次即可定位。</li>
<li>RTree 索引：一般不会使用，仅支持 geometry 数据类型，优势在于范围查找，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</li>
<li>全文索引：对文本的内容进行分词，进行搜索。目前只有 <code>CHAR</code>、<code>VARCHAR</code> ，<code>TEXT</code> 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</li>
</ul>
<p>按照底层存储方式角度划分：</p>
<ul>
<li>聚簇索引（聚集索引）：索引结构和数据一起存放的索引，InnoDB 中的主键索引就属于聚簇索引。</li>
<li>非聚簇索引（非聚集索引）：索引结构和数据分开存放的索引，二级索引(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。</li>
</ul>
<p>按照应用维度划分：</p>
<ul>
<li>主键索引：加速查询 + 列值唯一（不可以有 NULL）+ 表中只有一个。</li>
<li>普通索引：仅加速查询。</li>
<li>唯一索引：加速查询 + 列值唯一（可以有 NULL）。</li>
<li>覆盖索引：一个索引包含（或者说覆盖）所有需要查询的字段的值。</li>
<li>联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。</li>
<li>全文索引：对文本的内容进行分词，进行搜索。目前只有 <code>CHAR</code>、<code>VARCHAR</code> ，<code>TEXT</code> 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</li>
</ul>
<p>MySQL 8.x 中实现的索引新特性：</p>
<ul>
<li>隐藏索引：也称为不可见索引，不会被优化器使用，但是仍然需要维护，通常会软删除和灰度发布的场景中使用。主键不能设置为隐藏（包括显式设置或隐式设置）。</li>
<li>降序索引：之前的版本就支持通过 desc 来指定索引为降序，但实际上创建的仍然是常规的升序索引。直到 MySQL 8.x 版本才开始真正支持降序索引。另外，在 MySQL 8.x 版本中，不再对 GROUP BY 语句进行隐式排序。</li>
<li>函数索引：从 MySQL 8.0.13 版本开始支持在索引中使用函数或者表达式的值，也就是在索引中可以包含函数或者表达式。</li>
</ul>
<h2> 主键索引(Primary Key)</h2>
<p>数据表的主键列使用的就是主键索引。</p>
<p>一张数据表有只能有一个主键，并且主键不能为 null，不能重复。</p>
<p>在 MySQL 的 InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引且不允许存在 null 值的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键。</p>
<figure><figcaption>主键索引</figcaption></figure>
<h2> 二级索引</h2>
<p><strong>二级索引（Secondary Index）又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。</strong></p>
<p>唯一索引，普通索引，前缀索引等索引属于二级索引。</p>
<p>PS: 不懂的同学可以暂存疑，慢慢往下看，后面会有答案的，也可以自行搜索。</p>
<ol>
<li><strong>唯一索引(Unique Key)</strong>:唯一索引也是一种约束。唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。</li>
<li><strong>普通索引(Index)</strong>:普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。</li>
<li><strong>前缀索引(Prefix)</strong>:前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小，<br>
因为只取前几个字符。</li>
<li><strong>全文索引(Full Text)</strong>:全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。</li>
</ol>
<p>二级索引:</p>
<figure><figcaption>二级索引</figcaption></figure>
<h2> 聚簇索引与非聚簇索引</h2>
<h3> 聚簇索引（聚集索引）</h3>
<h4> 聚簇索引介绍</h4>
<p><strong>聚簇索引（Clustered Index）即索引结构和数据一起存放的索引，并不是一种单独的索引类型。InnoDB 中的主键索引就属于聚簇索引。</strong></p>
<p>在 MySQL 中，InnoDB 引擎的表的 <code>.ibd</code>文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。</p>
<h4> 聚簇索引的优缺点</h4>
<p><strong>优点</strong>：</p>
<ul>
<li><strong>查询速度非常快</strong>：聚簇索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。相比于非聚簇索引， 聚簇索引少了一次读取数据的 IO 操作。</li>
<li><strong>对排序查找和范围查找优化</strong>：聚簇索引对于主键的排序查找和范围查找速度非常快。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>依赖于有序的数据</strong>：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。</li>
<li><strong>更新代价大</strong>：如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且聚簇索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于主键索引来说，主键一般都是不可被修改的。</li>
</ul>
<h3> 非聚簇索引（非聚集索引）</h3>
<h4> 非聚簇索引介绍</h4>
<p><strong>非聚簇索引(Non-Clustered Index)即索引结构和数据分开存放的索引，并不是一种单独的索引类型。二级索引(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。</strong></p>
<p>非聚簇索引的叶子节点并不一定存放数据的指针，因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。</p>
<h4> 非聚簇索引的优缺点</h4>
<p><strong>优点</strong>：</p>
<p>更新代价比聚簇索引要小 。非聚簇索引的更新代价就没有聚簇索引那么大了，非聚簇索引的叶子节点是不存放数据的</p>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>依赖于有序的数据</strong>:跟聚簇索引一样，非聚簇索引也依赖于有序的数据</li>
<li><strong>可能会二次查询(回表)</strong>:这应该是非聚簇索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。</li>
</ul>
<p>这是 MySQL 的表的文件截图:</p>
<figure><figcaption>MySQL 表的文件</figcaption></figure>
<p>聚簇索引和非聚簇索引:</p>
<figure><figcaption>聚簇索引和非聚簇索引</figcaption></figure>
<h4> 非聚簇索引一定回表查询吗(覆盖索引)?</h4>
<p><strong>非聚簇索引不一定回表查询。</strong></p>
<p>试想一种情况，用户准备使用 SQL 查询用户名，而用户名字段正好建立了索引。</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>那么这个索引的 key 本身就是 name，查到对应的 name 直接返回就行了，无需回表查询。</p>
<p>即使是 MYISAM 也是这样，虽然 MYISAM 的主键索引确实需要回表，因为它的主键索引的叶子节点存放的是指针。但是！<strong>如果 SQL 查的就是主键呢?</strong></p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>主键索引本身的 key 就是主键，查到返回就行了。这种情况就称之为覆盖索引了。</p>
<h2> 覆盖索引和联合索引</h2>
<h3> 覆盖索引</h3>
<p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为 <strong>覆盖索引（Covering Index）</strong> 。我们知道在 InnoDB 存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次，这样就会比较慢。而覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！</p>
<p><strong>覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，而无需回表查询。</strong></p>
<blockquote>
<p>如主键索引，如果一条 SQL 需要查询主键，那么正好根据主键索引就可以查到主键。再如普通索引，如果一条 SQL 需要查询 name，name 字段正好有索引，<br>
那么直接根据这个索引就可以查到数据，也无需回表。</p>
</blockquote>
<figure><figcaption>覆盖索引</figcaption></figure>
<p>我们这里简单演示一下覆盖索引的效果。</p>
<p>1、创建一个名为 <code>cus_order</code> 的表，来实际测试一下这种排序方式。为了测试方便， <code>cus_order</code> 这张表只有 <code>id</code>、<code>score</code>、<code>name</code>这 3 个字段。</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2、定义一个简单的存储过程（PROCEDURE）来插入 100w 测试数据。</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>存储过程定义完成之后，我们执行存储过程即可！</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>等待一会，100w 的测试数据就插入完成了！</p>
<p>3、创建覆盖索引并使用 <code>EXPLAIN</code> 命令分析。</p>
<p>为了能够对这 100w 数据按照 <code>score</code> 进行排序，我们需要执行下面的 SQL 语句。</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用 <code>EXPLAIN</code> 命令分析这条 SQL 语句，通过 <code>Extra</code> 这一列的 <code>Using filesort</code> ，我们发现是没有用到覆盖索引的。</p>
<figure><figcaption></figcaption></figure>
<p>不过这也是理所应当，毕竟我们现在还没有创建索引呢！</p>
<p>我们这里以 <code>score</code> 和 <code>name</code> 两个字段建立联合索引：</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>创建完成之后，再用 <code>EXPLAIN</code> 命令分析再次分析这条 SQL 语句。</p>
<figure><figcaption></figcaption></figure>
<p>通过 <code>Extra</code> 这一列的 <code>Using index</code> ，说明这条 SQL 语句成功使用了覆盖索引。</p>
<p>关于 <code>EXPLAIN</code> 命令的详细介绍请看：<a href="https://javaguide.cn/database/mysql/mysql-query-execution-plan.html" target="_blank" rel="noopener noreferrer">MySQL 执行计划分析</a>这篇文章。</p>
<h3> 联合索引</h3>
<p>使用表中的多个字段创建索引，就是 <strong>联合索引</strong>，也叫 <strong>组合索引</strong> 或 <strong>复合索引</strong>。</p>
<p>以 <code>score</code> 和 <code>name</code> 两个字段建立联合索引：</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 最左前缀匹配原则</h3>
<p>最左前缀匹配原则指的是，在使用联合索引时，<strong>MySQL</strong> 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询（如 <strong><code>&gt;</code></strong>、<strong><code>&lt;</code></strong> ）才会停止匹配。对于 <strong><code>&gt;=</code></strong>、<strong><code>&lt;=</code></strong>、<strong><code>BETWEEN</code></strong>、<strong><code>like</code></strong> 前缀匹配的范围查询，并不会停止匹配。所以，我们在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。</p>
<p>相关阅读：<a href="https://mp.weixin.qq.com/s/8qemhRg5MgXs1So5YCv0fQ" target="_blank" rel="noopener noreferrer">联合索引的最左匹配原则全网都在说的一个错误结论</a>。</p>
<h2> 索引下推</h2>
<p><strong>索引下推（Index Condition Pushdown）</strong> 是 <strong>MySQL 5.6</strong> 版本中提供的一项索引优化功能，可以在非聚簇索引遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表次数。</p>
<h2> 正确使用索引的一些建议</h2>
<h3> 选择合适的字段创建索引</h3>
<ul>
<li><strong>不为 NULL 的字段</strong>：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。</li>
<li><strong>被频繁查询的字段</strong>：我们创建索引的字段应该是查询操作非常频繁的字段。</li>
<li><strong>被作为条件查询的字段</strong>：被作为 WHERE 条件查询的字段，应该被考虑建立索引。</li>
<li><strong>频繁需要排序的字段</strong>：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。</li>
<li><strong>被经常频繁用于连接的字段</strong>：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。</li>
</ul>
<h3> 被频繁更新的字段应该慎重建立索引</h3>
<p>虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。</p>
<h3> 限制每张表上的索引数量</h3>
<p>索引并不是越多越好，建议单张表索引不超过 5 个！索引可以提高效率同样可以降低效率。</p>
<p>索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。</p>
<p>因为 MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间，同样会降低查询性能。</p>
<h3> 尽可能的考虑建立联合索引而不是单列索引</h3>
<p>因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。</p>
<h3> 注意避免冗余索引</h3>
<p>冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。</p>
<h3> 字符串类型的字段使用前缀索引代替普通索引</h3>
<p>前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。</p>
<h3> 避免索引失效</h3>
<p>索引失效也是慢查询的主要原因之一，常见的导致索引失效的情况有下面这些：</p>
<ul>
<li><s>使用 <code>SELECT *</code> 进行查询;</s> <code>SELECT *</code> 不会直接导致索引失效（如果不走索引大概率是因为 where 查询范围过大导致的），但它可能会带来一些其他的性能问题比如造成网络传输和数据处理的浪费、无法使用索引覆盖;</li>
<li>创建了组合索引，但查询条件未准守最左匹配原则;</li>
<li>在索引列上进行计算、函数、类型转换等操作;</li>
<li>以 % 开头的 LIKE 查询比如 <code>LIKE '%abc';</code>;</li>
<li>查询条件中使用 OR，且 OR 的前后条件中有一个列没有索引，涉及的索引都不会被使用到;</li>
<li>IN 的取值范围较大时会导致索引失效，走全表扫描(NOT IN 和 IN 的失效场景相同);</li>
<li>发生<a href="https://javaguide.cn/database/mysql/index-invalidation-caused-by-implicit-conversion.html" target="_blank" rel="noopener noreferrer">隐式转换</a>;</li>
<li>……</li>
</ul>
<p>推荐阅读这篇文章：<a href="https://mp.weixin.qq.com/s/mwME3qukHBFul57WQLkOYg" target="_blank" rel="noopener noreferrer">美团暑期实习一面：MySQl 索引失效的场景有哪些？</a>。</p>
<h3> 删除长期未使用的索引</h3>
<p>删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗。</p>
<p>MySQL 5.7 可以通过查询 <code>sys</code> 库的 <code>schema_unused_indexes</code> 视图来查询哪些索引从未被使用。</p>
<h3> 知道如何分析语句是否走索引查询</h3>
<p>我们可以使用 <code>EXPLAIN</code> 命令来分析 SQL 的 <strong>执行计划</strong> ，这样就知道语句是否命中索引了。执行计划是指一条 SQL 语句在经过 MySQL 查询优化器的优化会后，具体的执行方式。</p>
<p><code>EXPLAIN</code> 并不会真的去执行相关的语句，而是通过 <strong>查询优化器</strong> 对语句进行分析，找出最优的查询方案，并显示对应的信息。</p>
<p><code>EXPLAIN</code> 的输出格式如下：</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>各个字段的含义如下：</p>
<table>
<thead>
<tr>
<th><strong>列名</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>SELECT 查询的序列标识符</td>
</tr>
<tr>
<td>select_type</td>
<td>SELECT 关键字对应的查询类型</td>
</tr>
<tr>
<td>table</td>
<td>用到的表名</td>
</tr>
<tr>
<td>partitions</td>
<td>匹配的分区，对于未分区的表，值为 NULL</td>
</tr>
<tr>
<td>type</td>
<td>表的访问方法</td>
</tr>
<tr>
<td>possible_keys</td>
<td>可能用到的索引</td>
</tr>
<tr>
<td>key</td>
<td>实际用到的索引</td>
</tr>
<tr>
<td>key_len</td>
<td>所选索引的长度</td>
</tr>
<tr>
<td>ref</td>
<td>当使用索引等值查询时，与索引作比较的列或常量</td>
</tr>
<tr>
<td>rows</td>
<td>预计要读取的行数</td>
</tr>
<tr>
<td>filtered</td>
<td>按表条件过滤后，留存的记录数的百分比</td>
</tr>
<tr>
<td>Extra</td>
<td>附加信息</td>
</tr>
</tbody>
</table>
<p>篇幅问题，我这里只是简单介绍了一下 MySQL 执行计划，详细介绍请看：<a href="https://javaguide.cn/database/mysql/mysql-query-execution-plan.html" target="_blank" rel="noopener noreferrer">MySQL 执行计划分析</a>这篇文章。</p>
]]></content:encoded>
    </item>
    <item>
      <title>99.9%的人都会犯错的几个Python小常识！</title>
      <link>https://vuepress-theme-hope-docs-demo.netlify.app/blog/%E5%87%A0%E4%B8%AA%E6%98%93%E9%94%99%E7%9A%84Python%E5%B0%8F%E5%B8%B8%E8%AF%86.html</link>
      <guid>https://vuepress-theme-hope-docs-demo.netlify.app/blog/%E5%87%A0%E4%B8%AA%E6%98%93%E9%94%99%E7%9A%84Python%E5%B0%8F%E5%B8%B8%E8%AF%86.html</guid>
      <source url="https://vuepress-theme-hope-docs-demo.netlify.app/rss.xml">99.9%的人都会犯错的几个Python小常识！</source>
      <description>大家好，我是暴走の海鸽~ 本期整理了几个基础python防坑小常识，希望对大家有所帮助。 1. type == object？ 执行以下代码的结果是什么： ```python isinstance(type, object) True isinstance(object, type) True isinstance(object, object)...</description>
      <pubDate>Tue, 05 Sep 2023 09:26:04 GMT</pubDate>
      <content:encoded><![CDATA[<p>大家好，我是暴走の海鸽~</p>
<p>本期整理了几个基础python防坑小常识，希望对大家有所帮助。</p>
<h2> 1. type == object？</h2>
<p>执行以下代码的结果是什么：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>
<p>isinstance(type, object)：这个表达式返回 True，因为在 Python 中，type 是一种类型，而 object 也是一种类型，它们都是对象的基类。</p>
</li>
<li>
<p>isinstance(object, type)：同样返回 True，因为 object 是 Python 中所有对象的基类，因此它也可以被视为一种类型。</p>
</li>
<li>
<p>isinstance(object, object)：这个表达式也返回 True，因为 object 是 object 类型的实例，它自己也是一种对象。</p>
</li>
<li>
<p>isinstance(type, type)：同样返回 True，因为 type 本身也是一种类型，可以用来描述其他类型。</p>
</li>
</ul>
<p>在 Python 中，所有东西都是对象，因此对于对象的任何实例检查都将返回<code>True</code>。</p>
<ul>
<li><code>isinstance(Anything, object) --&gt; True</code></li>
</ul>
<p>Python 的 type 表示构建所有 Python 类型的元类。因此，所有类型，如 int、str、object 都是 type 类的实例，而 type 类本身也是一个对象，与 Python 中的一切一样。</p>
<p>type 是 Python 中唯一一个自身是自己实例的对象。</p>
<h2> 2. all函数、any函数</h2>
<p>执行以下代码的结果是什么：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>根据内置函数 any 的定义，我们知道它将：</p>
<p>如果 iterable 中的任何元素为 True，则返回 True。</p>
<p>Python 中的逻辑运算符是惰性的，算法是查找第一个 True 元素的出现情况，如果没有找到，则返回 False。由于序列为空，因此没有元素可以是 True，因此 any([]) 返回 False。</p>
<p>all 的例子稍微有些复杂，因为它表示真空的真实性。与链式惰性逻辑运算符类似，算法是查找第一个 False 元素，如果没有找到，则返回 True。由于在空序列中没有false 元素，因此 all([]) 返回 True。</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 3. 链式运算</h2>
<p>执行以下代码的结果是什么：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><br>
在python中，<code>==</code>运算符和<code>in</code>运算符都具有相同的优先级，并且它们都是从左到右结合的。因此<code>False == False in [False]</code>实际上是<code>(False == False) and (False in [False]</code>的简写形式。</p>
<p>加个栗子理解下：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p><a href="https://stackoverflow.com/questions/7479808/python-operator-precedence-of-in-and-comparison" target="_blank" rel="noopener noreferrer">'1' in '11' == True</a><br>
<a href="https://docs.python.org/3/reference/expressions.html#operator-precedence" target="_blank" rel="noopener noreferrer">python运算符优先级和结合性</a></p>
</blockquote>
<h2> 4. sorted函数和reversed函数</h2>
<p>执行以下代码的结果是什么：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>注意：sorted 方法返回的是一个list，reversed 方法返回的是一个iterator。</p>
</blockquote>
<h2> 5. 布尔值</h2>
<p>执行以下代码的结果是什么：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>Python 将 False 视为 0， True 视为 1</p>
</blockquote>
<h2> 6. round函数</h2>
<p>执行以下代码的结果是什么：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为什么 round(5 / 2) 返回 2 而不是 3？这里的问题在于 Python 的 round 方法实现了银行家舍入，其中所有半值都将四舍五入到最接近的偶数。<br>
即：</p>
<ul>
<li>
<p>如果小数部分小于 0.5，则舍弃小数部分，不进行舍入。</p>
</li>
<li>
<p>如果小数部分大于 0.5，则向上舍入到最接近的整数。</p>
</li>
<li>
<p>如果小数部分等于 0.5，且前一位的整数部分是奇数，则向上舍入到最接近的偶数。</p>
</li>
<li>
<p>如果小数部分等于 0.5，且前一位的整数部分是偶数，则向下舍入到最接近的偶数。</p>
</li>
</ul>
<h2> 7. python列表+和+=的区别</h2>
<p><code>+</code></p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>+=</code></p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<ul>
<li><code>+</code>用于连接两个列表，生成一个新的列表。</li>
<li><code>+=</code>用于将一个列表与另一个列表相加，并将结果存储在原始列表中，修改原始列表。</li>
</ul>
</blockquote>
<h2> 8. 列表del元素</h2>
<p>执行以下代码的结果是什么：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行结果：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例中，我们试图删除列表中的偶数元素。然而，这个代码会导致错误，因为在删除元素后，列表的长度发生变化，但循环中的索引 <code>i</code> 仍然会增加，这可能会导致索引超出列表边界的错误。</p>
<p>为了避免这种错误，可以使用以下方法之一来移除元素：</p>
<ol>
<li>创建一个新列表，只包含要保留的元素，而不删除原始列表的元素。</li>
</ol>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2">
<li>使用倒序循环，以避免索引问题。</li>
</ol>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这些方法可以避免在移除元素时引发错误，并确保代码正常运行。</p>
<h2> 9. 修改sum([])的默认返回值</h2>
<p>我们知道<code>sum([])</code>的返回值为0，那有没有办法修改呢，比如返回<code>0.0</code>,答案是：有的。而且就在sum函数的签名里。</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 小结</h2>
<p>尽管如此，Python 仍然以其清晰透明的编程语言特性而闻名。在编写本文时，我遇到了许多这样的代码片段，它们可能在早期版本的 Python 中表现出反直觉的行为，但在新版本中得到了修复或社区的解释。上述示例代表了 Python 语法的某些边界情况，而在实际的商业项目中，遇到这些情况的机会相对较小。</p>
<p>然而，检查和理解这样的“陷阱”可以帮助您更深入地理解 Python 语言的内部结构，从而避免在编写代码时使用不常见的用例和可疑的编程做法，这可能会导致意外的错误和故障。因此，了解 Python 的行为和语法规则仍然是一个有价值的努力，尤其是对于那些希望编写高质量、可维护代码的开发人员来说。</p>
]]></content:encoded>
    </item>
    <item>
      <title>python面试题(2)</title>
      <link>https://vuepress-theme-hope-docs-demo.netlify.app/blog/20230830_kykj%E9%9D%A2%E8%AF%95%E9%A2%98.html</link>
      <guid>https://vuepress-theme-hope-docs-demo.netlify.app/blog/20230830_kykj%E9%9D%A2%E8%AF%95%E9%A2%98.html</guid>
      <source url="https://vuepress-theme-hope-docs-demo.netlify.app/rss.xml">python面试题(2)</source>
      <description>一、 使用python实现一个单例模式对象。 在 Python 中，你可以使用多种方法来实现单例模式，其中最常见的方法是使用装饰器或者元类。下面我会为你展示两种常见的实现方式：使用装饰器和使用元类。 1. 使用装饰器实现单例模式： ```python def singleton(cls): instances = {} def get_instance...</description>
      <pubDate>Tue, 29 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 一、 使用python实现一个单例模式对象。</h2>
<p>在 Python 中，你可以使用多种方法来实现单例模式，其中最常见的方法是使用装饰器或者元类。下面我会为你展示两种常见的实现方式：使用装饰器和使用元类。</p>
<p><strong>1. 使用装饰器实现单例模式：</strong></p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>2. 使用元类实现单例模式：</strong></p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这两种方法都可以实现单例模式，你可以根据自己的喜好选择其中一种。元类的方法在一些高级场景下可能更灵活，但装饰器的方法更为简洁。</p>
<p>当使用 <code>__new__</code> 函数来实现单例模式时，你可以在 <code>__new__</code> 方法中控制实例的创建和返回。这里我将为你展示如何使用 <code>__new__</code> 函数实现单例模式：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，<code>__new__</code> 方法首先检查 <code>_instance</code> 属性，如果该属性为 <code>None</code>，则创建一个新的实例并将其赋值给 <code>_instance</code>。如果 <code>_instance</code> 不为 <code>None</code>，则返回现有的实例。这样确保了只有一个实例被创建和使用。</p>
<p>注意，这种方法不是线程安全的。如果你需要在多线程环境下使用单例模式，你需要考虑线程安全性并可能采取额外的措施来保护 <code>_instance</code> 的访问和修改。</p>
<p><code>优化</code><br>
实现并发安全的单例模式需要考虑多线程或多进程环境下的竞争条件。以下是使用线程安全的方式来实现并发安全的单例模式的示例：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的示例中，我们使用了一个互斥锁 (<code>_lock</code>) 来确保在创建实例时只有一个线程能够进入临界区。这样可以防止多个线程同时创建实例，从而保证了单例模式的线程安全性。</p>
<p>请注意，这只是一个线程安全的示例。如果你需要在多进程环境中使用单例模式，你可能需要使用 <code>multiprocessing.Lock</code> 来实现进程间的同步。</p>
<p>此外，还可以考虑使用更高级的线程安全工具，例如 <code>threading.RLock</code> 或 <code>threading.Condition</code>，以便更好地满足你的并发需求。</p>
<blockquote>
<p>这里只是给出一些范例，具体使用及优化请根据实际场景适配。</p>
</blockquote>
<h2> 二、 请使用异步的方式（多进程/线程/协程等）循环交替打印A和B各50次。</h2>
<p>输出示例如下：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>协程版</code><br>
下面是使用异步协程的方式来实现交替打印 A 和 B 各 50 次的示例代码：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例中，我们定义了一个异步函数 <code>print_a_b</code> 来循环打印指定的值（'A' 或 'B'）。我们使用 <code>asyncio.Lock</code> 来确保打印操作的互斥，从而避免同时打印 A 和 B。</p>
<p>通过创建两个异步任务（分别打印 A 和 B），我们使用 <code>asyncio.gather</code> 来等待它们完成。</p>
<p>运行以上代码，你会得到类似于你描述的交替打印 A 和 B 的输出。注意，由于异步性质，可能会有微小的延迟，但总体上会保持交替打印。</p>
<p><code>多线程版</code></p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例中，我们定义了一个 AlternatePrinter 类，其中包含两个方法 print_a 和 print_b，分别用于打印 A 和 B。我们使用条件变量 threading.Condition 来确保线程的交替执行。在每次打印完后，线程会改变 turn 变量的值，然后通过 condition.notify() 唤醒等待的线程。</p>
<p>通过创建两个线程分别执行 print_a 和 print_b，线程将会交替打印 A 和 B。</p>
<p>运行以上代码，你会得到你所期望的交替打印 A 和 B 的输出。</p>
<h2> 三、你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</h2>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个问题可以使用二分查找来解决，以减少调用 <code>isBadVersion</code> 函数的次数。由于每个错误的版本之后的版本都是错误的，我们可以将问题转化为在版本列表中寻找第一个满足条件的版本，也就是找到最左边的 <code>True</code> 值。以下是使用二分查找的示例代码：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例中，我们使用二分查找来找到第一个错误的版本。我们初始化 <code>left</code> 和 <code>right</code> 分别为 1 和 n，然后在每一步中计算 <code>mid</code>，并根据 <code>isBadVersion(mid)</code> 的结果来更新 <code>left</code> 和 <code>right</code>。如果 <code>isBadVersion(mid)</code> 返回 <code>True</code>，说明当前版本是错误的，我们将搜索范围缩小到左半部分；否则，搜索范围缩小到右半部分。</p>
<p>最终，当 <code>left</code> 和 <code>right</code> 相等时，就找到了第一个错误的版本，返回该版本号即可。</p>
<p>这种方法有效地减少了对 <code>isBadVersion</code> 函数的调用次数，通过二分查找的方式快速定位到第一个错误的版本。</p>
<h2> 四、请简述下python中的__new__和__init__的区别。</h2>
<p>在Python中，<code>__new__</code> 和 <code>__init__</code> 是两个特殊的方法，用于创建和初始化对象。它们在类的实例化过程中起着不同的作用。</p>
<ol>
<li>
<p><code>__new__</code> 方法：</p>
<ul>
<li><code>__new__</code> 是一个类级别的方法，负责创建并返回实例对象。它在对象创建之前调用，并且通常是静态方法，接受一个类作为第一个参数，然后传递其他参数来创建实例。</li>
<li>该方法的主要作用是控制实例对象的创建过程，可以在创建实例之前做一些额外的处理，或者返回一个已有的实例（单例模式）。</li>
<li>如果重写了 <code>__new__</code> 方法，通常需要确保返回一个有效的实例对象，否则会导致后续的初始化（<code>__init__</code>）等步骤无法进行。</li>
</ul>
</li>
<li>
<p><code>__init__</code> 方法：</p>
<ul>
<li><code>__init__</code> 是一个实例级别的方法，负责初始化实例的属性。它在对象创建之后调用，接受实例对象作为第一个参数，然后可以传递其他参数来初始化实例的属性。</li>
<li>该方法的主要作用是设置对象的属性，进行一些必要的初始化操作。</li>
<li><code>__init__</code> 不负责创建实例对象，而是在实例已经创建之后，对其进行属性的初始化。</li>
</ul>
</li>
</ol>
<p>总结：</p>
<ul>
<li><code>__new__</code> 用于创建实例对象，它是类级别的方法，控制对象的创建过程。</li>
<li><code>__init__</code> 用于初始化实例对象的属性，它是实例级别的方法，对已经创建的对象进行属性的设置。</li>
</ul>
<p>通常情况下，当你想要自定义对象的创建过程时，你会重写 <code>__new__</code> 方法；而当你需要设置对象的属性或执行其他初始化操作时，你会重写 <code>__init__</code> 方法。</p>
<h2> 五、请描述下Python的多线程管理。</h2>
<p>在 Python 中，多线程管理是通过 <code>threading</code> 模块来实现的。Python 中的多线程是基于操作系统的线程实现的，但由于 Python 全局解释器锁（GIL）的存在，多线程并不能真正实现并行运行。GIL 导致在同一时刻只有一个线程可以执行 Python 字节码，从而限制了多线程在 CPU 密集型任务中的性能表现。</p>
<p>以下是 Python 多线程管理的一些关键概念和函数：</p>
<ol>
<li>
<p><strong>线程创建：</strong> 使用 <code>threading.Thread</code> 类可以创建一个新的线程。通过传入一个函数作为参数，可以指定线程要执行的操作。</p>
</li>
<li>
<p><strong>线程启动：</strong> 调用线程对象的 <code>start()</code> 方法会启动线程，并开始执行指定的函数。</p>
</li>
<li>
<p><strong>线程同步：</strong> 在多线程环境中，由于共享资源的存在，可能会出现竞争条件。为了确保线程安全，可以使用锁（<code>threading.Lock</code>）等同步原语来协调线程之间的操作。</p>
</li>
<li>
<p><strong>锁机制：</strong> 锁（<code>threading.Lock</code>）用于防止多个线程同时访问共享资源。在一个线程获得锁之后，其他线程必须等待锁被释放后才能获取锁。</p>
</li>
<li>
<p><strong>线程间通信：</strong> 多个线程之间可能需要相互通信和协调，可以使用 <code>threading.Event</code>、<code>threading.Condition</code>、<code>threading.Semaphore</code> 等进行线程间通信。</p>
</li>
<li>
<p><strong>线程状态：</strong> 线程可以处于不同的状态，如就绪、运行、阻塞等。可以使用线程对象的 <code>is_alive()</code> 方法来检查线程是否还在运行。</p>
</li>
<li>
<p><strong>守护线程：</strong> 可以将线程设置为守护线程（<code>thread.daemon = True</code>），这样在主线程退出时，守护线程会随之结束。</p>
</li>
<li>
<p><strong>线程池：</strong> <code>concurrent.futures</code> 模块提供了线程池和进程池的高级接口，用于并行地执行函数。</p>
</li>
</ol>
<p>需要注意的是，由于 GIL 的存在，Python 中的多线程主要适用于 I/O 密集型任务，如网络请求、文件操作等。对于 CPU 密集型任务，多线程并不能充分利用多核 CPU，此时可以考虑使用多进程来实现并行运算。</p>
<p>总的来说，Python 的多线程管理提供了一些基本的线程操作和同步机制，但由于 GIL 的限制，多线程在并行计算方面可能不如其他语言或多进程方式。</p>
<h2> 六、请列出Python中可变数据类型和不可变数据类型，CPython是如何实现的？</h2>
<p>在 Python 中，数据类型分为可变和不可变两种。可变数据类型是指对象的值可以被修改，而不可变数据类型是指对象的值一旦创建就无法更改。以下是 Python 中常见的可变和不可变数据类型：</p>
<p>可变数据类型（Mutable）：</p>
<ol>
<li>列表（List）</li>
<li>字典（Dictionary）</li>
<li>集合（Set）</li>
</ol>
<p>不可变数据类型（Immutable）：</p>
<ol>
<li>数字（int、float、complex）</li>
<li>字符串（str）</li>
<li>元组（tuple）</li>
<li>冻结集合（frozenset）</li>
</ol>
<p>CPython 是 Python 的标准实现，它在内存中的数据存储方式与数据类型的可变性密切相关。下面简要描述了 CPython 如何实现可变和不可变数据类型：</p>
<p><strong>可变数据类型（如列表、字典、集合）的实现：</strong></p>
<ol>
<li>在内存中创建一个对象，对象包含了实际的数据和相关的控制信息，如对象类型、大小等。</li>
<li>对象中的数据可以被修改，例如对列表进行添加、删除、修改等操作。这些操作可能会引起对象在内存中的位置发生变化，即重新分配内存空间。</li>
<li>当对象被修改时，CPython 会确保相关的引用仍然指向这个对象，从而保证所有引用该对象的变量都能看到修改后的值。</li>
</ol>
<p><strong>不可变数据类型（如数字、字符串、元组）的实现：</strong></p>
<ol>
<li>在内存中创建一个对象，对象包含实际的数据和控制信息。</li>
<li>一旦对象被创建，它的值就无法更改。如果对一个不可变对象进行修改操作，实际上会创建一个新的对象，并将修改后的值赋予新的对象。</li>
<li>不可变对象的值在内存中是固定的，这使得可以对多个变量共享同一个对象，从而节省内存。</li>
</ol>
<p>需要注意的是，不可变对象之所以被设计成不可变的，一方面是为了避免意外修改数据，另一方面是为了在实现中可以进行一些优化，例如缓存常见的不可变对象，以减少内存占用。</p>
<p>总之，CPython 的数据类型实现方式是基于对象和引用的，根据对象的可变性来决定如何存储和操作数据。这种实现方式使得 Python 的变量和数据类型的使用变得灵活且易于理解。</p>
<h2> 七、请简述下python 协程的实现原理？协程一般适用于什么场景？</h2>
<p>Python 协程的实现原理基于生成器（Generator）和 <code>yield</code> 关键字，以及使用特定的库（如 <code>asyncio</code>）来实现异步编程。协程通过避免阻塞并允许在单个线程内切换执行，实现了高效的异步操作。</p>
<p>实现协程的关键点如下：</p>
<ol>
<li>
<p><strong>生成器（Generator）：</strong> 生成器是一种特殊的函数，它使用 <code>yield</code> 关键字来暂停函数的执行并生成一个值，然后在后续调用中恢复执行。生成器在每次调用时会执行到 <code>yield</code> 语句，并将值返回给调用者。</p>
</li>
<li>
<p><strong><code>yield</code> 关键字：</strong> <code>yield</code> 用于将控制权返回给调用者，并且保留函数的状态。调用者可以使用 <code>.send()</code> 方法向生成器发送值，这个值会被 <code>yield</code> 表达式接收。</p>
</li>
<li>
<p><strong>异步库（如 asyncio）：</strong> 在 Python 中，为了实现高效的协程，通常使用异步库，如 <code>asyncio</code>。<code>asyncio</code> 提供了协程和事件循环，允许在单个线程内执行多个协程，根据需要进行切换。</p>
</li>
</ol>
<p>协程适用于以下场景：</p>
<ol>
<li>
<p><strong>异步编程：</strong> 协程在异步编程中起到关键作用。它可以处理大量并发任务，如网络请求、数据库查询等，而不会阻塞整个程序的执行。</p>
</li>
<li>
<p><strong>事件驱动编程：</strong> 协程适用于事件驱动的编程模型。例如，在用户交互、触发事件、消息传递等情况下，协程可以很好地处理异步任务。</p>
</li>
<li>
<p><strong>I/O 密集型任务：</strong> 当任务主要涉及 I/O 操作时，如读写文件、网络通信等，协程能够在 I/O 操作时切换到其他任务，从而提高程序的效率。</p>
</li>
<li>
<p><strong>并发任务管理：</strong> 协程可以方便地管理大量并发任务，而不需要关注线程或进程的开销和同步问题。</p>
</li>
</ol>
<p>总之，协程适用于需要高效处理异步操作和并发任务的场景。通过避免阻塞，协程可以在单线程内实现多个任务的协同执行，提高了程序的并发性能和响应性。</p>
<h2> 八、请简述Python的垃圾回收机制。</h2>
<p><a href="https://zhuanlan.zhihu.com/p/108683483" target="_blank" rel="noopener noreferrer">Python语法入门之垃圾回收机制</a><br>
<a href="https://cloud.tencent.com/developer/article/2045561" target="_blank" rel="noopener noreferrer">一文读懂Python垃圾回收机制</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>python面试题(1)</title>
      <link>https://vuepress-theme-hope-docs-demo.netlify.app/blog/20230829_%E6%B7%B1%E5%9C%B3%E5%8D%83%E5%B7%A1%E7%A7%91%E6%8A%80%E9%9D%A2%E8%AF%95%E9%A2%98.html</link>
      <guid>https://vuepress-theme-hope-docs-demo.netlify.app/blog/20230829_%E6%B7%B1%E5%9C%B3%E5%8D%83%E5%B7%A1%E7%A7%91%E6%8A%80%E9%9D%A2%E8%AF%95%E9%A2%98.html</guid>
      <source url="https://vuepress-theme-hope-docs-demo.netlify.app/rss.xml">python面试题(1)</source>
      <description>递归知道吗？简单说说吧 递归是一种算法或编程技术，它是指在解决问题时使用函数自身的调用。简单来说，递归是将一个问题分解成一个或多个与原问题类似但规模较小的子问题来解决的方法。这些子问题会不断地缩小，直到它们变得足够简单，可以直接求解。 递归的关键在于分解和基本情况（也称为递归基）： 1. 分解（Divide）： 在解决问题时，将问题分解成更小的子问题。...</description>
      <pubDate>Tue, 29 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 递归知道吗？简单说说吧</h2>
<p>递归是一种算法或编程技术，它是指在解决问题时使用函数自身的调用。简单来说，递归是将一个问题分解成一个或多个与原问题类似但规模较小的子问题来解决的方法。这些子问题会不断地缩小，直到它们变得足够简单，可以直接求解。</p>
<p>递归的关键在于分解和基本情况（也称为递归基）：</p>
<ol>
<li>
<p><strong>分解（Divide）：</strong> 在解决问题时，将问题分解成更小的子问题。每次递归调用时，问题的规模会减小，直到达到基本情况。</p>
</li>
<li>
<p><strong>基本情况（Base Case）：</strong> 这是递归的终止条件。当问题变得足够小，可以直接求解时，递归不再继续，而是返回一个确定的值。</p>
</li>
</ol>
<p>在使用递归时，确保每次递归调用都朝着基本情况靠近，以避免无限递归。如果每次递归调用都足够接近基本情况，递归最终会收敛到基本情况并停止。</p>
<p>一个经典的递归例子是计算阶乘。阶乘 n! 的定义是 n! = n * (n-1)!，其中基本情况是 0! = 1 和 1! = 1。</p>
<p>递归在编程中非常有用，但需要小心使用，因为不正确的递归调用可能导致无限循环和性能问题。理解问题如何被分解成更小的子问题以及何时达到基本情况是掌握递归的关键。</p>
<h2> 快排会吗？写一下?</h2>
<p>当然，我可以帮你写一个快速排序算法的示例代码。快速排序是一种常用的排序算法，它的基本思想是通过选择一个基准元素，将数组分成左右两部分，使得左边的元素都小于基准，右边的元素都大于基准，然后递归地对左右两部分进行排序。</p>
<p>以下是一个用 Python 实现的快速排序示例代码：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例中，<code>quick_sort</code> 函数接受一个列表 <code>arr</code> 作为输入，然后递归地对左右两部分进行排序，并将排好序的左、中、右三个部分合并起来，最终得到完整的有序数组。这个例子中的基准元素选择方法是取数组中间的元素，实际上也可以选择其他的方法。</p>
<p>请注意，虽然这个示例代码演示了快速排序的基本思想，但在实际应用中，为了避免在最坏情况下的性能问题，可能需要考虑一些优化措施，比如随机选择基准元素，使用三路快排等。</p>
<h2> s = "sdsdscdffgdfcsdsdsd", 计算字符串s中c出现的位置和次数</h2>
<p>要计算字符串中字符 "c" 出现的位置和次数，你可以使用以下 Python 代码：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码会遍历字符串 <code>s</code> 中的每个字符，如果字符等于目标字符 <code>c</code>，就将其位置添加到 <code>positions</code> 列表中，并增加计数器 <code>count</code> 的值。最后，打印出字符 "c" 的出现位置和总次数。</p>
]]></content:encoded>
    </item>
    <item>
      <title>50道SQL经典面试题(上)</title>
      <link>https://vuepress-theme-hope-docs-demo.netlify.app/blog/50%E9%81%93SQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98(%E4%B8%8A).html</link>
      <guid>https://vuepress-theme-hope-docs-demo.netlify.app/blog/50%E9%81%93SQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98(%E4%B8%8A).html</guid>
      <source url="https://vuepress-theme-hope-docs-demo.netlify.app/rss.xml">50道SQL经典面试题(上)</source>
      <description>原创 丶平凡世界 最近在收集SQL每日一题时，找到这套比较经典的SQL面试题。 &amp;#x20; 我根据题目重新梳理了一遍，包括表结构，表之间的关系，测试数据，题目，参考答案等。其中大部分参考答案在各种数据库平台上通用。 &amp;#x20; 由于题目数量较多（足足50道题），小伙伴们可能不容易消化理解，于是将内容分为上下两篇，希望对你有所帮助。 一、表结构 1、...</description>
      <pubDate>Wed, 23 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 50道SQL经典面试题(上)</h1>
<p>原创 丶平凡世界</p>
<p>最近在收集SQL每日一题时，找到这套比较经典的SQL面试题。  </p>
<p>我根据题目重新梳理了一遍，包括表结构，表之间的关系，测试数据，题目，参考答案等。其中大部分参考答案在各种数据库平台上通用。  </p>
<p>由于题目数量较多（足足50道题），小伙伴们可能不容易消化理解，于是将内容分为上下两篇，希望对你有所帮助。</p>
<p><strong>一、表结构</strong></p>
<p>1、学生表</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>2、课程表</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>3、教师表</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>4、成绩表</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>二、表之间的关系</strong></p>
<p>四张表之间的关系如下图：</p>
<figure><figcaption></figcaption></figure>
<p>我们来解读一下上面的关系：  </p>
<p>1、课程表Course的课程编号(Cid)作为主键，在成绩表(SC)中可以看到一个或多个学生的课程分数，两表之间是属于<code>1：n</code>的关系。同理学生表(Student)与成绩表(SC)也是<code>1：n</code>的关系</p>
<p>2、教师表Teacher的教师编号(Tid)作为主键，在课程表(Course)中可以带一门或多门课程，两表之间也是属于1：n的关系。</p>
<p><strong>三、测试数据</strong></p>
<p>1、学生表</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结果如下：</p>
<figure><figcaption></figcaption></figure>
<p>2、课程表</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结果如下：  </p>
<figure><figcaption></figcaption></figure>
<p>3、教师表</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结果如下：  </p>
<figure><figcaption></figcaption></figure>
<p>4、成绩表</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结果如下：  </p>
<figure><figcaption></figcaption></figure>
<p><strong>四、面试题及参考答案</strong></p>
<p>1、查询" 01 "课程比" 02"课程成绩高的学生的信息及课程分数</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2、查询同时存在" 01 "课程和"02 "课程的情况</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>3、查询存在" 01 "课程但可能不存在"02 "课程的情况(不存在时显示为 null )</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>4、查询不存在" 01 "课程但存在"02 "课程的情况</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>5、查询平均成绩大于等于 60 分的同学的学生编号和学生姓名和平均成绩</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>6、查询在 SC 表存在成绩的学生信息</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>7、查询所有同学的学生编号、学生姓名、选课总数、所有课程的总成绩(没成绩的显示为 null )</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>8、查有成绩的学生信息</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>9、查询「李」姓老师的数量 </p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>10、查询学过「张三」老师授课的同学的信息 </p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>11、查询没有学全所有课程的同学的信息 </p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>12、查询至少有一门课与学号为" 01 "的同学所学相同的同学的信息 </p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>13、查询和" 01 "号的同学学习的课程完全相同的其他同学的信息 </p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>14、查询没学过"张三"老师讲授的任一门课程的学生姓名 </p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>15、查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩 </p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>16、检索" 01 "课程分数小于 60，按分数降序排列的学生信息</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>17、按平均成绩从高到低显示所有学生的所有课程的成绩以及平均成绩</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>18、查询各科成绩最高分、最低分和平均分：</p>
<p>以如下形式显示：课程 ID，课程 name，最高分，最低分，平均分，及格率，中等率，优良率，优秀率  </p>
<p>及格为&gt;=60，中等为：70-80，优良为：80-90，优秀为：&gt;=90</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（提示：可以左右滑动代码）</p>
<p>19、按各科成绩进行排序，并显示排名， Score 重复时保留名次空缺</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>20 按各科成绩进行排序，并显示排名， Score 重复时合并名次</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>21、查询学生的总成绩，并进行排名，总分重复时保留名次空缺</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>22 、查询学生的总成绩，并进行排名，总分重复时不保留名次空缺</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>23、统计各科成绩各分数段人数：课程编号，课程名称，[100-85]，[85-70]，[70-60]，[60-0] 及所占百分比</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>24、查询各科成绩前三名的记录</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>25、查询每门课程被选修的学生数 </p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>50道SQL经典面试题(下)</title>
      <link>https://vuepress-theme-hope-docs-demo.netlify.app/blog/50%E9%81%93SQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98(%E4%B8%8B).html</link>
      <guid>https://vuepress-theme-hope-docs-demo.netlify.app/blog/50%E9%81%93SQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98(%E4%B8%8B).html</guid>
      <source url="https://vuepress-theme-hope-docs-demo.netlify.app/rss.xml">50道SQL经典面试题(下)</source>
      <description>50道SQL经典面试题(下)</description>
      <pubDate>Wed, 23 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 50道SQL经典面试题(下)</h1>
<p>原创 丶平凡世界 <a href="http://wiznote-desktop/ks/note/view/79a579df-0e97-4971-8f60-86ed3beffd85/92198ca5-d9f0-4d98-ab67-d20f976da33d/index.html?lang=zh-cn&amp;readerType=common&amp;isPersonalKb=1&amp;canEdit=1&amp;userGuid=79a579df-0e97-4971-8f60-86ed3beffd85&amp;alias=godl9211&amp;pSpacing=16&amp;darkBgColor=transparent&amp;darkTextColor=#f0f0f0&amp;isFromWizClipper=1&amp;xssNoFrame=1&amp;themeMode=auto&amp;resourcesPath=&amp;frameKey=normal_note_92198ca5-d9f0-4d98-ab67-d20f976da33d" target="_blank" rel="noopener noreferrer">SQL数据库开发</a> </p>
<p>最近在收集SQL每日一题时，找到这套比较经典的SQL面试题。  </p>
<p>我根据题目重新梳理了一遍，包括表结构，表之间的关系，测试数据，题目，参考答案等。其中大部分参考答案在各种数据库平台上通用。  </p>
<p>由于题目数量较多（足足50道题），小伙伴们可能不容易消化理解，于是将内容分为上下两篇，希望对你有所帮助。</p>
<p><strong>一、表结构</strong></p>
<p>1、学生表</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>2、课程表</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>3、教师表</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>4、成绩表</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>二、表之间的关系</strong></p>
<p>四张表之间的关系如下图：</p>
<figure><figcaption></figcaption></figure>
<p>我们来解读一下上面的关系：  </p>
<p>1、课程表Course的课程编号(Cid)作为主键，在成绩表(SC)中可以看到一个或多个学生的课程分数，两表之间是属于<code>1：n</code>的关系。同理学生表(Student)与成绩表(SC)也是<code>1：n</code>的关系</p>
<p>2、教师表Teacher的教师编号(Tid)作为主键，在课程表(Course)中可以带一门或多门课程，两表之间也是属于1：n的关系。</p>
<p><strong>三、测试数据</strong></p>
<p>1、学生表</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结果如下：</p>
<figure><figcaption></figcaption></figure>
<p>2、课程表</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结果如下：  </p>
<figure><figcaption></figcaption></figure>
<p>3、教师表</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结果如下：  </p>
<figure><figcaption></figcaption></figure>
<p>4、成绩表</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结果如下：  </p>
<figure><figcaption></figcaption></figure>
<p><strong>四、面试题及参考答案</strong></p>
<p>26、查询出只选修两门课程的学生学号和姓名 </p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>27、查询男生、女生人数</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>28、查询名字中含有「风」字的学生信息</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>29、查询同名同性学生名单，并统计这些人数</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>30、查询 1990 年出生的学生名单</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>31、查询每门课程的平均成绩，结果按平均成绩降序排列，平均成绩相同时，按课程编号升序排列</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>32、查询平均成绩大于等于 85 的所有学生的学号、姓名和平均成绩 </p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>33、查询课程名称为「数学」，且分数低于 60 的学生姓名和分数</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>34、查询所有学生的课程及分数情况（存在学生没成绩，没选课的情况）</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>35、查询任何一门课程成绩在 70 分以上的姓名、课程名称和分数</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>36、查询不及格的课程学生姓名，课程名及分数</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>37、查询课程编号为01且课程成绩在80分以上的学生的学号和姓名</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>38、求每门课程的学生人数（假设每个学生都有参加考试且有成绩）</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>39、成绩不重复，查询选修「张三」老师所授课程的学生中，成绩最高的学生信息及其成绩</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>40、成绩有重复的情况下，查询选修「张三」老师所授课程的学生中，成绩最高的学生信息及其成绩</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>41、查询每门功成绩最好的前两名</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>42、统计每门课程的学生选修人数（超过5人的课程才统计），要求输出课程号和选修人数，查询结果按人数降序排列，若人数相同，按课程号升序排列</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>43、检索至少选修两门课程的学生学号 </p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>44、查询选修了全部课程的学生信息</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>45、查询各学生的年龄，只按年份来算</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>46、按照出生日期来算，当前月日小于出生日期的月日则年龄减1岁</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>47、查询本周过生日的学生</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>48、查询下周过生日的学生</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>49、查询本月过生日的学生</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>50、查询下月过生日的学生</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上就是50道经典SQL面试题的全部内容</p>
]]></content:encoded>
    </item>
    <item>
      <title>golang学习路线</title>
      <link>https://vuepress-theme-hope-docs-demo.netlify.app/blog/20230821_golang%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF.html</link>
      <guid>https://vuepress-theme-hope-docs-demo.netlify.app/blog/20230821_golang%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF.html</guid>
      <source url="https://vuepress-theme-hope-docs-demo.netlify.app/rss.xml">golang学习路线</source>
      <description>前言 为了方便大家能够按顺序系统的进行学习，我会将相关文章进行梳理。 让我们手牵着手，一起走，少走弯路，又快又好的成为Gopher，Let&amp;apos;s Go。 总体路线 概览 首先分享了我的学习经验：讲一讲Go语言为什么值得学习？以及我是如何高效学习Go语言的。 然后就是刻意练习了，需要大家和我一样，坚持每天手撸代码，多敲多想：通过对Go基础篇的学习，可以从...</description>
      <pubDate>Tue, 22 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 前言</h2>
<p>为了方便大家能够按顺序系统的进行学习，我会将相关文章进行梳理。</p>
<p>让我们手牵着手，一起走，少走弯路，又快又好的成为<strong>Gopher</strong>，Let's Go。</p>
<h2> 总体路线</h2>
<h2> 概览</h2>
<p>首先分享了我的<strong>学习经验</strong>：讲一讲Go语言为什么值得学习？以及我是如何高效学习Go语言的。</p>
<p>然后就是刻意练习了，需要大家和我一样，坚持每天手撸代码，多敲多想：</p>
<ul>
<li>
<p>通过对<strong>Go基础篇</strong>的学习，可以从Go小白升级成为能用Go撸代码的gopher。</p>
</li>
<li>
<p>通过对<strong>Go进阶篇</strong>的学习，可以从Go初级程序员升级为Go中级工程师。</p>
</li>
<li>
<p>通过<strong>Go  JAVA类比篇</strong>的学习，可以更好的理解Go的优势，更好的理解Go的设计思想。</p>
</li>
<li>
<p><strong>框架篇</strong> 不仅对比了目前主流的Go框架，还重点讲解了GoFrame框架相关的知识点。</p>
</li>
</ul>
<p><strong>GoFrame</strong>是类似PHP-Laravel, Java-SpringBoot的Go企业级开发框架，非常值得大家学习。</p>
<p>最后，会通过几篇<strong>应用实践</strong>的文章收尾，带大家体验一下用Go开发企业项目的快乐。</p>
<blockquote>
<p>说明：下面的文章没有标注作者信息的是我的文章；标明作者的都是优秀创作者投稿，经过筛选的优质文章。</p>
</blockquote>
<h2> 为什么学Go?</h2>
<p><a href="https://juejin.cn/post/7064778754979004447" target="_blank" rel="noopener noreferrer"># Go语言为什么值得学习？</a> 作者：王中阳</p>
<p><a href="https://juejin.cn/post/7110226868418117639" target="_blank" rel="noopener noreferrer"># Go 在云原生时代的优势</a> 作者：<a href="https://juejin.cn/user/3526889034751639" target="_blank" rel="noopener noreferrer"># 宇宙之一粟</a></p>
<h2> 学习经验分享</h2>
<p><a href="https://juejin.cn/post/6949109361331568670" target="_blank" rel="noopener noreferrer"># 回顾一下我的Go学习之旅 | Go 主题月</a> 作者：王中阳</p>
<p><a href="https://juejin.cn/post/7061777327641853960" target="_blank" rel="noopener noreferrer"># [译]如何真正学习Go 语言</a> 作者：<a href="https://juejin.cn/user/3526889034751639" target="_blank" rel="noopener noreferrer"># 宇宙之一粟</a></p>
<p><a href="https://juejin.cn/post/7103887534299545613" target="_blank" rel="noopener noreferrer"># 写Go最近踩的坑 | 日志、内聚和复用、gjson、调整心态</a></p>
<h2> golang筑基之路</h2>
<h3> 入门视频及系列教程</h3>
<ul>
<li>
<p><a href="https://www.bilibili.com/video/BV1gf4y1r79E/?spm_id_from=333.999.0.0&amp;vd_source=f6ed028b29a932df5d0a09a54802e1b5" target="_blank" rel="noopener noreferrer">刘丹冰老师教学视频:8小时转职Golang工程师</a></p>
</li>
<li>
<p><a href="https://www.liwenzhou.com/posts/Go/golang-menu/" target="_blank" rel="noopener noreferrer">李文周老师博客</a></p>
</li>
</ul>
<h3> 数据类型</h3>
<p><a href="https://juejin.cn/post/6942795881049489438/" target="_blank" rel="noopener noreferrer">#【Go基础】编译、变量、常量、基本数据类型、字符串</a></p>
<p><a href="https://juejin.cn/post/7068456474133364743/" target="_blank" rel="noopener noreferrer"># Go const和iota 使用实战</a></p>
<p><a href="https://juejin.cn/post/7068457967133130782" target="_blank" rel="noopener noreferrer"># Go基础数据类型使用实战：int float bool</a></p>
<h3> 切片</h3>
<p><a href="https://juejin.cn/post/7071960543283642404" target="_blank" rel="noopener noreferrer"># Go slice切片详解和实战</a></p>
<p><a href="https://juejin.cn/post/7068573594879524894" target="_blank" rel="noopener noreferrer"># Go slice切片详解和实战(2) make append copy</a></p>
<p><a href="https://juejin.cn/post/7122495050067476510" target="_blank" rel="noopener noreferrer"># 深入理解 slice 非常硬核！</a> 作者：<a href="https://juejin.cn/user/2344623087289965" target="_blank" rel="noopener noreferrer"># 二牛QAQ</a></p>
<h3> 数组</h3>
<p><a href="https://juejin.cn/post/7072165701036802055" target="_blank" rel="noopener noreferrer"># Go 数组详解和实战</a></p>
<p><a href="https://juejin.cn/post/7072905649708859429" target="_blank" rel="noopener noreferrer"># Go map详解和实战</a></p>
<h3> rune</h3>
<p><a href="https://juejin.cn/post/7068726981159829541" target="_blank" rel="noopener noreferrer"># Go rune详解和实战</a></p>
<h3> 指针</h3>
<p><a href="https://juejin.cn/post/7072502044170387492" target="_blank" rel="noopener noreferrer"># Go pointer &amp; switch fallthrough 详解和实战</a></p>
<h3> 流程控制</h3>
<p><a href="https://juejin.cn/post/7069549500649439245" target="_blank" rel="noopener noreferrer"># go if判断和for循环实战 goto使用的那些坑</a></p>
<h3> 函数</h3>
<p><a href="https://juejin.cn/post/7073279289101123614" target="_blank" rel="noopener noreferrer"># Go 函数详解 func 匿名函数 闭包</a></p>
<h3> ORM</h3>
<p><a href="https://www.liwenzhou.com/posts/Go/gorm/" target="_blank" rel="noopener noreferrer"># GORM入门指南</a> 作者</p>
<p><a href="https://juejin.cn/post/7103531271803912199" target="_blank" rel="noopener noreferrer"># Go 语言中操作 MySQL 数据库</a> 作者：<a href="https://juejin.cn/user/3526889034751639" target="_blank" rel="noopener noreferrer"># 宇宙之一粟</a></p>
<p><a href="https://juejin.cn/post/7147214210324234271" target="_blank" rel="noopener noreferrer"># golang 基于 mysql 实现分布式读写锁</a> 作者：<a href="https://juejin.cn/user/2344623087289965" target="_blank" rel="noopener noreferrer"># 二牛QAQ</a></p>
<h3> 部署</h3>
<p><a href="https://juejin.cn/post/6943843305750970399" target="_blank" rel="noopener noreferrer"># 如何优雅的通过Shell脚本一键部署GO项目到服务器</a></p>
<h3> 扩展包</h3>
<p><a href="https://juejin.cn/post/6943897665960689678" target="_blank" rel="noopener noreferrer"># Go时间包jsontime深入浅出 如何优雅的对时间进行格式化 ｜Go 主题月</a></p>
<p><a href="https://juejin.cn/post/6945023713930641445" target="_blank" rel="noopener noreferrer"># Go语言json包的使用技巧</a></p>
<p><a href="https://juejin.cn/post/7088342353638850567" target="_blank" rel="noopener noreferrer"># Go 入门很简单：如何在 Go 中使用日志包</a> 作者：<a href="https://juejin.cn/user/3526889034751639" target="_blank" rel="noopener noreferrer"># 宇宙之一粟</a></p>
<h3> 重要概念</h3>
<p><a href="https://juejin.cn/post/6950954283068031012" target="_blank" rel="noopener noreferrer"># Go开发web必懂的概念和底层原理，通过对比的方式让大家更好的理解 | Go主题月</a></p>
<h2> golang结丹之路</h2>
<h3> 协程</h3>
<p><a href="https://juejin.cn/post/6943952470993272845" target="_blank" rel="noopener noreferrer"># 什么时候用Goroutine？什么时候用Channel？</a></p>
<p><a href="https://juejin.cn/post/6950952506176471071" target="_blank" rel="noopener noreferrer"># Goroutine就是协程：进程 线程 协程 各自的概念以及三者的对比分析</a></p>
<h3> RPC</h3>
<p><a href="https://juejin.cn/post/6946452659159171102" target="_blank" rel="noopener noreferrer"># Go RPC入门指南1：RPC的使用边界在哪里？如何实现跨语言调用？</a></p>
<h3> 反射</h3>
<p><a href="https://juejin.cn/post/6844903559335526407" target="_blank" rel="noopener noreferrer"># Golang的反射reflect深入理解和示例</a> 作者：<a href="https://juejin.cn/user/1187128287436808" target="_blank" rel="noopener noreferrer">吴德宝AllenWu</a></p>
<p><a href="https://juejin.cn/post/7097534989029343246" target="_blank" rel="noopener noreferrer"># Go语言中的反射</a> 作者：<a href="https://juejin.cn/user/184373685261719" target="_blank" rel="noopener noreferrer">任沫</a></p>
<h3> interface</h3>
<p><a href="https://juejin.cn/post/6844903555141222407" target="_blank" rel="noopener noreferrer"># Golang interface接口深入理解</a> 作者：<a href="https://juejin.cn/user/1187128287436808" target="_blank" rel="noopener noreferrer">吴德宝AllenWu</a></p>
<h3> 错误处理</h3>
<p><a href="https://juejin.cn/post/7114970981872959525" target="_blank" rel="noopener noreferrer"># Go函数并发情况的错误处理</a> 作者：<a href="https://juejin.cn/user/1239904847411406" target="_blank" rel="noopener noreferrer">Masters</a></p>
<h3> 并发安全</h3>
<p><a href="https://juejin.cn/post/7068192854761275429" target="_blank" rel="noopener noreferrer"># Go源码解读-sync.Map的实现</a> 作者：<a href="https://juejin.cn/user/1239904847411406" target="_blank" rel="noopener noreferrer">Masters</a></p>
<h3> 部署</h3>
<p><a href="https://juejin.cn/post/6954309251892248612" target="_blank" rel="noopener noreferrer"># Go打包 部署 优雅的把Go项目部署到Linux服务器</a></p>
<h3> 规范&amp;技巧</h3>
<p><a href="https://juejin.cn/post/7082536852590166029" target="_blank" rel="noopener noreferrer"># Go语言中比较优雅的写法 | 硬核！</a></p>
<p><a href="https://juejin.cn/post/7086094606856618014" target="_blank" rel="noopener noreferrer"># 爆肝分享两千字Go编程规范</a></p>
<p><a href="https://juejin.cn/post/7102605823003590692" target="_blank" rel="noopener noreferrer"># Go开发技巧和踩坑分享 | 代码结构 调试技巧 配置文件 元数据</a></p>
<h3> Go对比PHP/JAVA/C</h3>
<p><a href="https://juejin.cn/post/7118866795418615822" target="_blank" rel="noopener noreferrer"># Java VS Go 还在纠结怎么选吗，(资深后端4000字带你深度对比)</a> 作者：<a href="https://juejin.cn/user/2472125987040093" target="_blank" rel="noopener noreferrer">TodoCoder</a></p>
<p><a href="https://juejin.cn/post/7105012753210802213" target="_blank" rel="noopener noreferrer"># 为什么我觉得GoFrame的garray比PHP的array还好用？</a></p>
<p><a href="https://juejin.cn/post/7105231214390280200" target="_blank" rel="noopener noreferrer"># GoFrame gset使用入门 | 对比PHP、Java、Redis</a></p>
<p><a href="https://juejin.cn/post/7077843585088897037" target="_blank" rel="noopener noreferrer"># 如何在 Go 代码中运行 C 语言代码</a> 作者：<a href="https://juejin.cn/user/3526889034751639" target="_blank" rel="noopener noreferrer"># 宇宙之一粟</a></p>
<h3> 好用的扩展包</h3>
<p><a href="https://juejin.cn/post/7119390985863299085" target="_blank" rel="noopener noreferrer"># GO语言框架中如何快速集成日志模块</a> 作者：<a href="https://juejin.cn/user/1239904847411406" target="_blank" rel="noopener noreferrer">Masters</a></p>
<p><a href="https://juejin.cn/post/7102001354654089223" target="_blank" rel="noopener noreferrer"># Go Web 编程入门：Go pongo2 模板引擎</a> 作者：<a href="https://juejin.cn/user/3526889034751639" target="_blank" rel="noopener noreferrer"># 宇宙之一粟</a></p>
<p><a href="https://juejin.cn/post/7120256019225116679" target="_blank" rel="noopener noreferrer"># 使用 Gorilla Mux 和 CockroachDB 编写可维护 RESTful API</a> 作者：<a href="https://juejin.cn/user/3526889034751639" target="_blank" rel="noopener noreferrer"># 宇宙之一粟</a></p>
<h3> 设计模式</h3>
<p><a href="https://juejin.cn/post/7124720007447052302" target="_blank" rel="noopener noreferrer"># golang 设计模式-单例模式</a> 作者：<a href="https://juejin.cn/user/2344623087289965" target="_blank" rel="noopener noreferrer"># 二牛QAQ</a></p>
<h3> 框架篇</h3>
<h4> 学哪个框架？</h4>
<p><a href="https://juejin.cn/post/7067347764899741709" target="_blank" rel="noopener noreferrer"># Go主流框架对比：Gin Echo Beego Iris</a></p>
<p><a href="https://juejin.cn/post/7075098594151235597" target="_blank" rel="noopener noreferrer"># 非常适合PHP/JAVA同学使用的GO框架：GoFrame</a></p>
<p><a href="https://juejin.cn/post/7119348879820554247" target="_blank" rel="noopener noreferrer"># 12个值得一看的Go开源项目/框架</a> 作者：<a href="https://juejin.cn/user/3008695929418318" target="_blank" rel="noopener noreferrer">ReganYue</a></p>
<h4> Gin框架&amp;中间件</h4>
<p><a href="https://juejin.cn/post/6943147832937447431" target="_blank" rel="noopener noreferrer"># Go gin框架封装中间件之1：用户角色权限管理中间件</a></p>
<p><a href="https://juejin.cn/post/6943503384729583652" target="_blank" rel="noopener noreferrer"># Go gin框架封装中间件之2：操作日志中间件</a></p>
<h4> GORM</h4>
<p><a href="https://juejin.cn/post/6945404499850854408" target="_blank" rel="noopener noreferrer"># Go GORM是时候升级新版本了 2.0新特性介绍（1）</a></p>
<p><a href="https://juejin.cn/post/6946012224573931528" target="_blank" rel="noopener noreferrer"># Go GORM是时候升级新版本了 2.0新特性介绍（2）| Go主题月</a></p>
<h4> Echo</h4>
<p><a href="https://juejin.cn/post/7068555737756073997" target="_blank" rel="noopener noreferrer"># 回声嘹亮 之 Go 的 Echo 框架指南 —— 上手初体验</a> 作者：<a href="https://juejin.cn/user/3526889034751639" target="_blank" rel="noopener noreferrer"># 宇宙之一粟</a></p>
<h4> Beego</h4>
<p><a href="https://juejin.cn/post/7121536082151211022" target="_blank" rel="noopener noreferrer"># go-web框架-beego的使用</a> 作者：<a href="https://juejin.cn/user/3421335915080093" target="_blank" rel="noopener noreferrer"># jy白了个白</a></p>
<h4> GoFrame</h4>
<h3> 数据结构</h3>
<p><a href="https://juejin.cn/post/7105012753210802213" target="_blank" rel="noopener noreferrer"># 为什么我觉得GoFrame的garray比PHP的array还好用？</a></p>
<p><a href="https://juejin.cn/post/7090901734247104548" target="_blank" rel="noopener noreferrer"># GoFrame garray使用实践</a></p>
<p><a href="https://juejin.cn/post/7105231214390280200" target="_blank" rel="noopener noreferrer"># GoFrame gset使用入门 | 对比PHP、Java、Redis</a></p>
<p><a href="https://juejin.cn/post/7105572330612457486" target="_blank" rel="noopener noreferrer"># GoFrame gset使用实践 | 交差并补集</a></p>
<p><a href="https://juejin.cn/post/7106013158279479327" target="_blank" rel="noopener noreferrer"># GoFrame gset使用技巧总结 | 出栈、子集判断、序列化、遍历修改</a></p>
<p><a href="https://juejin.cn/post/7101515355062796296" target="_blank" rel="noopener noreferrer"># GoFrame glist 基础使用和自定义遍历</a></p>
<p><a href="https://juejin.cn/post/7101797623484383246" target="_blank" rel="noopener noreferrer"># GoFrame gmap详解 hashmap、listmap、treemap使用技巧</a></p>
<p><a href="https://juejin.cn/post/7106458930057855013" target="_blank" rel="noopener noreferrer"># GoFrame gtree 使用入门 | 养成读源码的好习惯</a></p>
<h3> 类型转换</h3>
<p><a href="https://juejin.cn/post/7081078067682082823" target="_blank" rel="noopener noreferrer"># GoFrame代码优化：使用gconv类型转换 避免重复定义map</a></p>
<h3> 通用变量</h3>
<p><a href="https://juejin.cn/post/7106712908326764552" target="_blank" rel="noopener noreferrer"># GoFrame 通用类型变量gvar | 对比 interface{}</a></p>
<h3> 数据校验</h3>
<p><a href="https://juejin.cn/post/7110222819631464485" target="_blank" rel="noopener noreferrer"># GoFrame数据校验之校验对象 | 校验结构体</a></p>
<p><a href="https://juejin.cn/post/7110952333193773064" target="_blank" rel="noopener noreferrer"># GoFrame数据校验之校验结果 | Error接口对象</a></p>
<p><a href="https://juejin.cn/post/7113360526410776583" target="_blank" rel="noopener noreferrer"># GoFrame如何实现顺序性校验</a></p>
<h3> 错误处理</h3>
<p><a href="https://juejin.cn/post/7112428421392629773" target="_blank" rel="noopener noreferrer"># GoFrame错误处理的常用方法&amp;错误码的使用</a></p>
<h3> 上下文</h3>
<p><a href="https://juejin.cn/post/7113118741776793636" target="_blank" rel="noopener noreferrer"># GoFrame 如何优雅的共享变量 | Context的使用</a></p>
<p><a href="https://juejin.cn/post/7123200814402764831" target="_blank" rel="noopener noreferrer"># Go 并发编程基础：什么是上下文</a> 作者：<a href="https://juejin.cn/user/3526889034751639" target="_blank" rel="noopener noreferrer"># 宇宙之一粟</a></p>
<h3> ORM</h3>
<p><a href="https://juejin.cn/post/7082278651681013773" target="_blank" rel="noopener noreferrer"># GoFrame ORM 使用实践分享</a></p>
<p><a href="https://juejin.cn/post/7089980894525521957" target="_blank" rel="noopener noreferrer"># GoFrame ORM原生方法 开箱体验 （上）</a></p>
<p><a href="https://juejin.cn/post/7090358951501365278" target="_blank" rel="noopener noreferrer"># GoFrame ORM原生方法 开箱体验 （下）</a></p>
<p><a href="https://juejin.cn/post/7084569454956249101" target="_blank" rel="noopener noreferrer"># GoFrame必知必会之Scan：类型转换</a></p>
<h3> 缓存管理</h3>
<p><a href="https://juejin.cn/post/7109465768445607967" target="_blank" rel="noopener noreferrer"># GoFrame 如何优雅的缓存查询结果</a></p>
<p><a href="https://juejin.cn/post/7107986667293638663" target="_blank" rel="noopener noreferrer"># GoFrame gcache使用实践 | 缓存控制 淘汰策略</a></p>
<p><a href="https://juejin.cn/post/7108272085452980261" target="_blank" rel="noopener noreferrer"># GoFrame gredis 配置管理 | 配置文件、配置方法的对比</a></p>
<p><a href="https://juejin.cn/post/7108698563328081928" target="_blank" rel="noopener noreferrer"># GoFrame gredis 硬核解析 | DoVar、Conn连接对象、自动序列化</a></p>
<p><a href="https://juejin.cn/post/7109092852101021704" target="_blank" rel="noopener noreferrer"># GoFrame gredis 如何优雅的取值和类型转换</a></p>
<h3> 协程管理</h3>
<p><a href="https://juejin.cn/post/7102979667925139463" target="_blank" rel="noopener noreferrer"># GoFrame gpool 对象复用池 | 对比sync.pool</a></p>
<p><a href="https://juejin.cn/post/7103502362429358116" target="_blank" rel="noopener noreferrer"># goFrame的gqueue详解 | 对比channel</a></p>
<p><a href="https://juejin.cn/post/7104661248213516319" target="_blank" rel="noopener noreferrer"># grpool goroutine池详解 | 协程管理</a></p>
<h3> 避坑指南</h3>
<p><a href="https://juejin.cn/post/7081959981456556068" target="_blank" rel="noopener noreferrer"># GoFrame避坑指南和实践干货</a></p>
<p><a href="https://juejin.cn/post/7085730973836378126" target="_blank" rel="noopener noreferrer"># GoFrame避坑指南和实践干货（2）</a></p>
<h3> 性能测试</h3>
<p><a href="https://juejin.cn/post/7110510747498594341" target="_blank" rel="noopener noreferrer"># GoFrame grpool性能测试 | 对比原生goroutine</a></p>
<h3> 调试&amp;单元测试</h3>
<p><a href="https://juejin.cn/post/7111325551549218823" target="_blank" rel="noopener noreferrer"># Go本地测试 如何解耦 任务拆解&amp;沟通</a></p>
<p><a href="https://juejin.cn/post/7115009937847091214" target="_blank" rel="noopener noreferrer"># Go Web 编程入门： 一探优秀测试库 GoConvey</a> 作者：<a href="https://juejin.cn/user/3526889034751639" target="_blank" rel="noopener noreferrer"># 宇宙之一粟</a></p>
<h1> 应用实践</h1>
<p><a href="https://juejin.cn/post/7099449898529095717" target="_blank" rel="noopener noreferrer"># gtoken替换jwt实现sso登录 | 带你读源码</a></p>
<p><a href="https://juejin.cn/post/7102389025050361864" target="_blank" rel="noopener noreferrer"># gtoken替换jwt实现sso登录 | 排雷避坑</a></p>
<p><a href="https://juejin.cn/post/7083479769878102030" target="_blank" rel="noopener noreferrer"># Go对接三方API实践</a></p>
<p><a href="https://juejin.cn/post/7084235852921962503" target="_blank" rel="noopener noreferrer"># Go一分钟对接ElasticSearch实践</a></p>
<p><a href="https://juejin.cn/post/7068192828790145060" target="_blank" rel="noopener noreferrer"># 瞄一眼clickhouse(附 go demo)</a> 作者：<a href="https://juejin.cn/user/1239904847411406" target="_blank" rel="noopener noreferrer">Masters</a></p>
<h1> Git</h1>
<p><a href="https://juejin.cn/post/7018771333173477383" target="_blank" rel="noopener noreferrer"># Git使用实战：多人协同开发，紧急修复线上bug的Git操作指南。</a></p>
<p><a href="https://juejin.cn/post/7104258964732575775" target="_blank" rel="noopener noreferrer"># Git 重命名远程分支 | 操作不规范，亲人两行泪。</a></p>
<h1> 刷题</h1>
<p>如果你是学生党，没有机会接触商业项目，不用难过。刷力扣是个非常好的选择！</p>
<p><a href="https://juejin.cn/column/7070334316957401125" target="_blank" rel="noopener noreferrer">用Go语言刷力扣专栏</a></p>
<p>为了方便大家刷Go语言的知识点，特意整理了面试题相关的文章：</p>
<p><a href="https://juejin.cn/post/7131717990558466062" target="_blank" rel="noopener noreferrer"># 【狂刷面试题】GO常见面试题汇总</a></p>
<h1> 一起学习</h1>
<p><strong>这是收藏破万的：</strong><a href="https://juejin.cn/post/7119123646471208968" target="_blank" rel="noopener noreferrer"># 《Go学习路线图》让你少走弯路，升职加薪。</a></p>
<h2> 资料</h2>
<ul>
<li>
<p><a href="https://www.bilibili.com/video/BV1gf4y1r79E/?spm_id_from=333.999.0.0&amp;vd_source=f6ed028b29a932df5d0a09a54802e1b5" target="_blank" rel="noopener noreferrer"># 刘丹冰老师教学视频:8小时转职Golang工程师</a></p>
</li>
<li>
<p><a href="https://www.liwenzhou.com/posts/Go/golang-menu/" target="_blank" rel="noopener noreferrer"># 李文周老师博客</a></p>
</li>
<li>
<p><a href="https://juejin.cn/column/7140137480749547528" target="_blank" rel="noopener noreferrer"># 王中阳签约专栏：Go语言进阶实战</a></p>
</li>
<li>
<p><a href="https://space.bilibili.com/20942052?spm_id_from=333.337.0.0" target="_blank" rel="noopener noreferrer"># 楚国刮大风：go手写redis</a></p>
</li>
<li>
<p><a href="https://space.bilibili.com/317473362?spm_id_from=333.337.0.0" target="_blank" rel="noopener noreferrer"># 小徐先生1212：Golang专栏</a></p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>python学习路线</title>
      <link>https://vuepress-theme-hope-docs-demo.netlify.app/blog/20230821_python%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF.html</link>
      <guid>https://vuepress-theme-hope-docs-demo.netlify.app/blog/20230821_python%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF.html</guid>
      <source url="https://vuepress-theme-hope-docs-demo.netlify.app/rss.xml">python学习路线</source>
      <pubDate>Mon, 21 Aug 2023 00:00:00 GMT</pubDate>
    </item>
    <item>
      <title>程序员面试刷题路线</title>
      <link>https://vuepress-theme-hope-docs-demo.netlify.app/blog/20230821_%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98%E8%B7%AF%E7%BA%BF.html</link>
      <guid>https://vuepress-theme-hope-docs-demo.netlify.app/blog/20230821_%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98%E8%B7%AF%E7%BA%BF.html</guid>
      <source url="https://vuepress-theme-hope-docs-demo.netlify.app/rss.xml">程序员面试刷题路线</source>
      <description>大家好，我是海鸽 金九银十马上到了，海鸽在此整理下面试刷题准备路线供你参考，希望对你有所帮助~ 程序员面试的刷题路线可以根据你的目标岗位和面试准备时间的长短来进行调整。 MySQL刷题 连环炮 1. 为什么索引能提高查询速度? 2. 聚集索引和非聚集索引的区别？非聚集索引一定回表查询吗? 3. 索引这么多优点，为什么不对表中的每一个列创建一个索引呢？(...</description>
      <pubDate>Wed, 23 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>大家好，我是<code>海鸽</code></p>
<p>金九银十马上到了，海鸽在此整理下面试刷题准备路线供你参考，希望对你有所帮助~</p>
<p>程序员面试的刷题路线可以根据你的目标岗位和面试准备时间的长短来进行调整。</p>
<h2> MySQL刷题</h2>
<h3> 连环炮</h3>
<ol>
<li>为什么索引能提高查询速度?</li>
<li>聚集索引和非聚集索引的区别？非聚集索引一定回表查询吗?</li>
<li>索引这么多优点，为什么不对表中的每一个列创建一个索引呢？(使用索引一定能提高查询性能吗?)</li>
<li>索引底层的数据结构了解么？Hash 索引和 B+树索引优劣分析</li>
<li>B+树做索引比红黑树好在哪里？</li>
<li>最左前缀匹配原则了解么？</li>
<li>什么是覆盖索引</li>
<li>如何查看某条SQL语句是否用到了索引？</li>
<li>索引为什么用B+树而不用B树？</li>
<li>说一说项目中MySQL分库分表怎么做的？</li>
<li>说一说垂直分表和水平分表？</li>
</ol>
<h3> 参考</h3>
<ul>
<li>这里推荐田螺哥开源的一个刷题仓库，这里不仅可以刷MySQL常见面试题，还囊括了JAVA开发的各种技能的面试准备，仓库的地址是：</li>
</ul>
<blockquote>
<p><a href="https://github.com/whx123/JavaHome/tree/master" target="_blank" rel="noopener noreferrer">https://github.com/whx123/JavaHome/tree/master</a></p>
</blockquote>
<ul>
<li>
<p><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html" target="_blank" rel="noopener noreferrer">MySQL高性能优化规范建议总结</a></p>
</li>
<li>
<p><a href="https://mp.weixin.qq.com/s/K3fJU73--kMsOP1UpxKFsQ" target="_blank" rel="noopener noreferrer">面对这些MySQL线上事故，你会怎么做性能优化？</a></p>
</li>
<li>
<p><a href="https://www.yuque.com/snailclimb/mf2z3k/abc2sv" target="_blank" rel="noopener noreferrer">高性能：有哪些常见的 SQL 优化手段？</a></p>
</li>
<li>
<p><a href="https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&amp;mid=2247499624&amp;idx=1&amp;sn=561b9cb7fe831ca7cb2d9fd65691e85e&amp;chksm=cf222041f855a957ac50c0a53baaec6d26be32427259b2974450620f33a8c834419fe535e83d&amp;token=767319274&amp;lang=zh_CN&amp;scene=21#wechat_redirect:~:text=%E7%9B%98%E7%82%B9MySQL%E6%85%A2%E6%9F%A5%E8%AF%A2%E7%9A%8412%E4%B8%AA%E5%8E%9F%E5%9B%A0,-%E5%8E%9F%E5%88%9B" target="_blank" rel="noopener noreferrer">盘点MySQL慢查询的12个原因</a></p>
</li>
<li>
<p><a href="https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&amp;mid=2247504369&amp;idx=1&amp;sn=8628a5aaec0dc8f85d06080e11072ce2&amp;chksm=cf220ed8f85587ce7f7dfebdaf160b7b54bdca6a773411e59f8df5f50604760a5c121c088bb5&amp;token=1211708820&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">SQL优化13连问，收藏好！</a></p>
</li>
<li>
<p><a href="https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&amp;mid=2247490571&amp;idx=1&amp;sn=e8638573ec8d720fd25da5b2b0d90ed2&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">看一遍就理解：order by详解</a></p>
</li>
<li>
<p><a href="https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&amp;mid=2247487972&amp;idx=1&amp;sn=cd035a7fcd7496658846ab9f914be2db&amp;chksm=cf21cecdf85647dbc53e212bf1a2b95d0eb2bffe08dc0141e01f8a9b2088abffc385a2ef584e&amp;token=1569911403&amp;lang=zh_CN&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">后端程序员必备：书写高质量SQL的30条建议</a></p>
</li>
<li>
<p><a href="https://www.bilibili.com/video/BV1Kr4y1i7ru/?p=69&amp;share_source=copy_web&amp;vd_source=8945d0055d36f5037ca23022a4925f2a&amp;t=4" target="_blank" rel="noopener noreferrer">黑马mysql</a></p>
</li>
</ul>
<h2> Redis刷题</h2>
<h3> 连环炮</h3>
<ol>
<li>说一说Redis的缓存雪崩、缓存穿透、缓存击穿，以及对应的解决方案？</li>
<li>说一说你们项目中Redis的缓存不一致，怎么解决的？</li>
<li>Redis中如何实现分布式锁的？</li>
<li>我看你写到的Redis多级缓存架构，你们是怎么做的？</li>
</ol>
<h3> 参考</h3>
<p><a href="https://www.sharkchili.com/pages/5d69b6/" target="_blank" rel="noopener noreferrer">Redis持久化AOF详解</a></p>
<h2> 算法刷题</h2>
<blockquote>
<p><code>LeetCode</code>：<a href="https://leetcode.cn/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/</a><br>
<code>恋上数据结构与算法</code><br>
<code>代码随想录</code></p>
</blockquote>
]]></content:encoded>
    </item>
  </channel>
</rss>