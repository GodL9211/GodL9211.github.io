import{_ as o}from"./plugin-vue_export-helper-c27b6911.js";import{r as i,o as p,c as l,a as n,b as a,e,f as t}from"./app-9976b6d0.js";const r={},c=t('<h1 id="rest-framework专栏讲解-十四-validators" tabindex="-1"><a class="header-anchor" href="#rest-framework专栏讲解-十四-validators" aria-hidden="true">#</a> Rest-framework专栏讲解(十四)：Validators</h1><h2 id="目录" tabindex="-1"><a class="header-anchor" href="#目录" aria-hidden="true">#</a> 目录</h2><ul><li><a href="#%E9%AA%8C%E8%AF%81%E5%99%A8">验证器</a><ul><li><a href="#REST-framework-%E4%B8%AD%E7%9A%84%E9%AA%8C%E8%AF%81">REST framework 中的验证</a><ul><li><a href="#%E4%B8%BE%E4%B8%AA%E6%A0%97%E5%AD%90">举个栗子</a></li><li><a href="#UniqueValidator">UniqueValidator</a></li><li><a href="#UniqueTogetherValidator">UniqueTogetherValidator</a></li><li><a href="#UniqueForDateValidatorUniqueForMonthValidatorUniqueForYearValidator">UniqueForDateValidator、UniqueForMonthValidator、UniqueForYearValidator</a><ul><li><a href="#%E4%B8%8E%E5%8F%AF%E5%86%99%E6%97%A5%E6%9C%9F%E5%AD%97%E6%AE%B5%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8">与可写日期字段一起使用</a></li><li><a href="#%E4%B8%8E%E5%8F%AA%E8%AF%BB%E6%97%A5%E6%9C%9F%E5%AD%97%E6%AE%B5%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8">与只读日期字段一起使用</a></li><li><a href="#%E4%B8%8E%E9%9A%90%E8%97%8F%E7%9A%84%E6%97%A5%E6%9C%9F%E5%AD%97%E6%AE%B5%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8">与隐藏的日期字段一起使用</a></li></ul></li><li><a href="#%E9%BB%98%E8%AE%A4%E5%80%BC%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95">默认值高级用法</a><ul><li><a href="#Advanced-field-defaults">Advanced field defaults</a></li><li><a href="#CurrentUserDefault">CurrentUserDefault</a></li><li><a href="#CreateOnlyDefault">CreateOnlyDefault</a></li></ul></li></ul></li></ul></li><li><a href="#%E9%AA%8C%E8%AF%81%E5%99%A8%E7%9A%84%E9%99%90%E5%88%B6">验证器的限制</a><ul><li><a href="#%E5%8F%AF%E9%80%89%E5%AD%97%E6%AE%B5">可选字段</a></li><li><a href="#%E6%9B%B4%E6%96%B0%E5%B5%8C%E5%A5%97%E5%BA%8F%E5%88%97%E5%8C%96%E7%B1%BB">更新嵌套序列化类</a></li><li><a href="#%E8%B0%83%E8%AF%95%E5%A4%8D%E6%9D%82%E7%9A%84%E6%A1%88%E4%BE%8B">调试复杂的案例</a></li></ul></li><li><a href="#%E7%BC%96%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89%E9%AA%8C%E8%AF%81%E5%99%A8">编写自定义验证器</a><ul><li><a href="#%E5%9F%BA%E4%BA%8E%E5%87%BD%E6%95%B0">基于函数</a><ul><li><a href="#%E5%AD%97%E6%AE%B5%E7%BA%A7%E9%AA%8C%E8%AF%81">字段级验证</a></li></ul></li><li><a href="#%E5%9F%BA%E4%BA%8E%E7%B1%BB">基于类</a><ul><li><a href="#%E4%BD%BF%E7%94%A8-set_context">使用 set_context()</a></li></ul></li></ul></li></ul><hr>',4),d={href:"http://www.django-rest-framework.org/api-guide/validators/",title:"官方原文链接",target:"_blank",rel:"noopener noreferrer"},u={id:"验证器",tabindex:"-1"},k=n("a",{class:"header-anchor",href:"#验证器","aria-hidden":"true"},"#",-1),h={href:"http://drf.jiuyou.info/#/drf/validators?id=%E9%AA%8C%E8%AF%81%E5%99%A8",title:"验证器",target:"_blank",rel:"noopener noreferrer"},v=n("p",null,"大多数情况下，您在 REST framework 中处理验证时，只需依赖默认的字段验证，或者在序列化类或字段类上编写明确的验证方法。",-1),m=n("p",null,"但是，有时你会希望将验证逻辑放置到可重用组件中，以便在整个代码库中轻松地重用它。这可以通过使用验证器函数和验证器类来实现。",-1),f={id:"rest-framework-中的验证",tabindex:"-1"},_=n("a",{class:"header-anchor",href:"#rest-framework-中的验证","aria-hidden":"true"},"#",-1),b={href:"http://drf.jiuyou.info/#/drf/validators?id=rest-framework-%E4%B8%AD%E7%9A%84%E9%AA%8C%E8%AF%81",title:"REST framework 中的验证",target:"_blank",rel:"noopener noreferrer"},E=t("<p>Django REST framework 序列化器中的验证与 Django <code>ModelForm</code> 类中验证的工作方式有点不同。</p><p>使用 <code>ModelForm</code>，验证一部分在表单上执行，一部分在模型实例上执行。使用 REST framework ，验证完全在序列化类上执行。这是有优势的，原因如下：</p><ul><li>它使问题适当的分离，让代码行为变的更加清晰。</li><li>使用快捷的 <code>ModelSerializer</code> 类和使用显式的 <code>Serializer</code> 类可以轻松切换。任何用于 <code>ModelSerializer</code> 的验证行为都很容易复制。</li><li>打印序列化类实例的 <code>repr</code> 将会显示它应用的验证规则。在模型实例上没有额外的隐藏验证行为（因为全在序列化类上）。</li></ul><p>当你使用 <code>ModelSerializer</code> 时，所有验证都会自动为你处理。如果你想要改为使用 <code>Serializer</code> 类，那么你需要明确定义验证规则。</p><p>在你使用 REST 框架进行验证处理时, 你可能仅仅依赖于默认依赖的字段验证, 或者在 serializer 上使用显式验证的方法, 但如果将验证逻辑代码放入可复用的组件中, 即可达到复用代码, 降低冗余的效果, 而这个功能就可以<code>通过验证类或者验证函数来实现</code>。</p>",5),g={id:"举个栗子",tabindex:"-1"},A=n("a",{class:"header-anchor",href:"#举个栗子","aria-hidden":"true"},"#",-1),y={href:"http://drf.jiuyou.info/#/drf/validators?id=%E4%B8%BE%E4%B8%AA%E6%A0%97%E5%AD%90",title:"举个栗子",target:"_blank",rel:"noopener noreferrer"},B=t(`<p>作为 REST framework 如何使用显式验证的示例，我们将采用一个简单的模型类，该类具有唯一性约束的字段。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">CustomerReportRecord</span><span class="token punctuation">(</span>models<span class="token punctuation">.</span>Model<span class="token punctuation">)</span><span class="token punctuation">:</span>
    time_raised <span class="token operator">=</span> models<span class="token punctuation">.</span>DateTimeField<span class="token punctuation">(</span>default<span class="token operator">=</span>timezone<span class="token punctuation">.</span>now<span class="token punctuation">,</span> editable<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>
    reference <span class="token operator">=</span> models<span class="token punctuation">.</span>CharField<span class="token punctuation">(</span>unique<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> max_length<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">)</span>
    description <span class="token operator">=</span> models<span class="token punctuation">.</span>TextField<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>CustomerReportSerializer</code> 是一个基本的 <code>ModelSerializer</code> ，我们可以使用它来创建或更新 <code>CustomerReportRecord</code> 的实例：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">CustomerReportSerializer</span><span class="token punctuation">(</span>serializers<span class="token punctuation">.</span>ModelSerializer<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">class</span> <span class="token class-name">Meta</span><span class="token punctuation">:</span>
        model <span class="token operator">=</span> CustomerReportRecord
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在使用 <code>manage.py shell</code> 打开 Django shell:</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token keyword">from</span> project<span class="token punctuation">.</span>example<span class="token punctuation">.</span>serializers <span class="token keyword">import</span> CustomerReportSerializer
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> serializer <span class="token operator">=</span> CustomerReportSerializer<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">repr</span><span class="token punctuation">(</span>serializer<span class="token punctuation">)</span><span class="token punctuation">)</span>
CustomerReportSerializer<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token builtin">id</span> <span class="token operator">=</span> IntegerField<span class="token punctuation">(</span>label<span class="token operator">=</span><span class="token string">&#39;ID&#39;</span><span class="token punctuation">,</span> read_only<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
    time_raised <span class="token operator">=</span> DateTimeField<span class="token punctuation">(</span>read_only<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
    reference <span class="token operator">=</span> CharField<span class="token punctuation">(</span>max_length<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">,</span> validators<span class="token operator">=</span><span class="token punctuation">[</span><span class="token operator">&lt;</span>UniqueValidator<span class="token punctuation">(</span>queryset<span class="token operator">=</span>CustomerReportRecord<span class="token punctuation">.</span>objects<span class="token punctuation">.</span><span class="token builtin">all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    description <span class="token operator">=</span> CharField<span class="token punctuation">(</span>style<span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">&#39;type&#39;</span><span class="token punctuation">:</span> <span class="token string">&#39;textarea&#39;</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里有趣的是 <code>reference</code> 字段。我们可以看到唯一性约束由序列化字段上的验证器明确执行。</p><p>由于这种更明确的风格，REST framework 包含一些在核心 Django 中没有的验证器类。这些类在下面详细说明。</p><h3 id="uniquevalidator" tabindex="-1"><a class="header-anchor" href="#uniquevalidator" aria-hidden="true">#</a> UniqueValidator</h3><p>该验证器可用于在模型字段上强制实施 <code>unique=True</code> 约束。它需要一个必需的参数和一个可选的 <code>messages</code> 参数：</p><ul><li><code>queryset</code> <em>必须</em> - 这是验证唯一性的查询集。</li><li><code>message</code> - 验证失败时使用的错误消息。</li><li><code>lookup</code> - 用于查找已验证值的现有实例。默认为 <code>&#39;exact&#39;</code>。</li></ul><p>这个验证器应该应用于序列化字段，如下所示：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">from</span> rest_framework<span class="token punctuation">.</span>validators <span class="token keyword">import</span> UniqueValidator

<span class="token keyword">class</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">:</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    slug <span class="token operator">=</span> SlugField<span class="token punctuation">(</span>
        max_length<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">,</span>
        validators<span class="token operator">=</span><span class="token punctuation">[</span>UniqueValidator<span class="token punctuation">(</span>queryset<span class="token operator">=</span>BlogPost<span class="token punctuation">.</span>objects<span class="token punctuation">.</span><span class="token builtin">all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
    <span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="uniquetogethervalidator" tabindex="-1"><a class="header-anchor" href="#uniquetogethervalidator" aria-hidden="true">#</a> UniqueTogetherValidator</h3><p>此验证器可用于在模型实例上强制实施 <code>unique_together</code> 约束。它有两个必需的参数和一个可选的 <code>messages</code> 参数：</p><ul><li><code>queryset</code> <em>必须</em> - 这是验证唯一性的查询集。</li><li><code>fields</code> <em>必须</em> - 一个存放字段名称的列表或者元组，这个集合必须是唯一的（意思是集合中的字段代表的一组值不能同时出现在两条数据中）。这些字段必须都是序列化类中的字段。</li><li><code>message</code> - 验证失败时使用的错误消息。</li></ul><p>验证器应该应用于序列化类，如下所示：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">from</span> rest_framework<span class="token punctuation">.</span>validators <span class="token keyword">import</span> UniqueTogetherValidator

<span class="token keyword">class</span> <span class="token class-name">ExampleSerializer</span><span class="token punctuation">(</span>serializers<span class="token punctuation">.</span>Serializer<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">class</span> <span class="token class-name">Meta</span><span class="token punctuation">:</span>
        validators <span class="token operator">=</span> <span class="token punctuation">[</span>
            UniqueTogetherValidator<span class="token punctuation">(</span>
                queryset<span class="token operator">=</span>ToDoItem<span class="token punctuation">.</span>objects<span class="token punctuation">.</span><span class="token builtin">all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                fields<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">&#39;list&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;position&#39;</span><span class="token punctuation">]</span>
            <span class="token punctuation">)</span>
        <span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意</strong>: <code>UniqueTogetherValidation</code> 类总是施加一个隐式约束，即它所应用的所有字段都是按需处理的。具有 <code>default</code> 值的字段是一个例外，因为它们总是提供一个值，即使在用户输入中省略了这个值。</p><h3 id="uniquefordatevalidator、uniqueformonthvalidator、uniqueforyearvalidator" tabindex="-1"><a class="header-anchor" href="#uniquefordatevalidator、uniqueformonthvalidator、uniqueforyearvalidator" aria-hidden="true">#</a> UniqueForDateValidator、UniqueForMonthValidator、UniqueForYearValidator</h3><p>这些验证器可用于强制实施模型实例上的 <code>unique_for_date</code>，<code>unique_for_month</code> 和 <code>unique_for_year</code> 约束。他们有以下参数：</p><ul><li><code>queryset</code> <em>必须</em> - 这是验证唯一性的查询集。</li><li><code>field</code> <em>必须</em> - 在给定日期范围内需要被验证唯一性的字段的名称。该字段必须是序列化类中的字段。</li><li><code>date_field</code> <em>必须</em> - 将用于确定唯一性约束的日期范围的字段名称。该字段必须是序列化类中的字段。</li><li><code>message</code> - 验证失败时使用的错误消息。</li></ul><p>验证器应该应用于序列化类，如下所示：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">from</span> rest_framework<span class="token punctuation">.</span>validators <span class="token keyword">import</span> UniqueForYearValidator

<span class="token keyword">class</span> <span class="token class-name">ExampleSerializer</span><span class="token punctuation">(</span>serializers<span class="token punctuation">.</span>Serializer<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">class</span> <span class="token class-name">Meta</span><span class="token punctuation">:</span>
        validators <span class="token operator">=</span> <span class="token punctuation">[</span>
            UniqueForYearValidator<span class="token punctuation">(</span>
                queryset<span class="token operator">=</span>BlogPostItem<span class="token punctuation">.</span>objects<span class="token punctuation">.</span><span class="token builtin">all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                field<span class="token operator">=</span><span class="token string">&#39;slug&#39;</span><span class="token punctuation">,</span>
                date_field<span class="token operator">=</span><span class="token string">&#39;published&#39;</span>
            <span class="token punctuation">)</span>
        <span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>我解释下，上面例子的意思是，在 <code>published</code> 日期所在的年份中，<code>slug</code> 字段的值必须唯一，注意，不是要和 <code>published</code> 完全相等的日期，而是年份相等。<code>unique_for_date</code>，<code>unique_for_month</code> 同理。</p></blockquote><p>用于验证的日期字段应该始终存在于序列化类中。你不能简单地依赖模型类 <code>default=...</code>，因为默认值在验证运行之后才会生成。</p><p>你可能需要使用几种样式，具体取决于你希望 API 如何展现。如果你使用的是 <code>ModelSerializer</code> ，可能只需依赖 REST framework 为你生成的默认值，但如果你使用的是 <code>Serializer</code> 或需要更明确的控制，请使用下面演示的样式。</p><h4 id="与可写日期字段一起使用" tabindex="-1"><a class="header-anchor" href="#与可写日期字段一起使用" aria-hidden="true">#</a> 与可写日期字段一起使用</h4><p>如果你希望日期字段是可写的，唯一值得注意的是你应该确保它始终可用于输入数据中，可以通过设置 default 参数或通过设置 required=True 来实现。。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code>published <span class="token operator">=</span> serializers<span class="token punctuation">.</span>DateTimeField<span class="token punctuation">(</span>required<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="与只读日期字段一起使用" tabindex="-1"><a class="header-anchor" href="#与只读日期字段一起使用" aria-hidden="true">#</a> 与只读日期字段一起使用</h4><p>如果希望日期字段可见, 但用户不可编辑, 则设置 <code>read_only=True</code> 并另外设置一个 <code>default=...</code> 参数。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code>published <span class="token operator">=</span> serializers<span class="token punctuation">.</span>DateTimeField<span class="token punctuation">(</span>read_only<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> default<span class="token operator">=</span>timezone<span class="token punctuation">.</span>now<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="与隐藏的日期字段一起使用" tabindex="-1"><a class="header-anchor" href="#与隐藏的日期字段一起使用" aria-hidden="true">#</a> 与隐藏的日期字段一起使用</h4><p>如果您希望日期字段对用户完全隐藏, 请使用 <code>HiddenField</code>, 此字段类型不接受用户输入, 而是始终将其默认值返回给序列化器中的 <code>validated_data</code>。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code>published <span class="token operator">=</span> serializers<span class="token punctuation">.</span>HiddenField<span class="token punctuation">(</span>default<span class="token operator">=</span>timezone<span class="token punctuation">.</span>now<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>注意</strong>: <code>UniqueFor&lt;Range&gt;Validation</code> 类总是施加一个隐式约束，即它所应用的所有字段都是按需处理的。具有 <code>default</code> 值的字段是一个例外，因为它们总是提供一个值，即使在用户输入中省略了这个值</p><h3 id="默认值高级用法" tabindex="-1"><a class="header-anchor" href="#默认值高级用法" aria-hidden="true">#</a> 默认值高级用法</h3>`,38),F={id:"advanced-field-defaults",tabindex:"-1"},x=n("a",{class:"header-anchor",href:"#advanced-field-defaults","aria-hidden":"true"},"#",-1),w={href:"http://drf.jiuyou.info/#/drf/validators?id=advanced-field-defaults",title:"Advanced field defaults",target:"_blank",rel:"noopener noreferrer"},q=t(`<p>在序列化类的多个字段中应用的验证器有时不需要由 API 客户端提供的字段输入，但它可以用作验证器的输入。</p><p>有两种模式可能需要这种验证：</p><ul><li>使用 <code>HiddenField</code> 。该字段将出现在 <code>validated_data</code> 中，但不会用在序列化输出表示中。</li><li>使用 <code>read_only=True</code> 的标准字段，同时也包含 <code>default=...</code> 参数。该字段将用于序列化输出表示中，但不能由用户直接设置。</li></ul><p>REST framework 包含一些在这种情况下可能有用的默认值。</p><h4 id="currentuserdefault" tabindex="-1"><a class="header-anchor" href="#currentuserdefault" aria-hidden="true">#</a> CurrentUserDefault</h4><p>可用于表示当前用户的默认类。为了使用它，在实例化序列化类时，<code>&#39;request&#39;</code> 必须作为上下文字典的一部分提供。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code>owner <span class="token operator">=</span> serializers<span class="token punctuation">.</span>HiddenField<span class="token punctuation">(</span>
    default<span class="token operator">=</span>serializers<span class="token punctuation">.</span>CurrentUserDefault<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="createonlydefault" tabindex="-1"><a class="header-anchor" href="#createonlydefault" aria-hidden="true">#</a> CreateOnlyDefault</h4><p>可用于在 create 操作期间仅设置默认参数的默认类。在 update 期间，该字段被省略。</p><p>它接受一个参数，这是在 create 操作期间应该使用的默认值或可调用参数。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code>created_at <span class="token operator">=</span> serializers<span class="token punctuation">.</span>DateTimeField<span class="token punctuation">(</span>
    default<span class="token operator">=</span>serializers<span class="token punctuation">.</span>CreateOnlyDefault<span class="token punctuation">(</span>timezone<span class="token punctuation">.</span>now<span class="token punctuation">)</span>
<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,11),z={id:"验证器的限制",tabindex:"-1"},D=n("a",{class:"header-anchor",href:"#验证器的限制","aria-hidden":"true"},"#",-1),C={href:"http://drf.jiuyou.info/#/drf/validators?id=%E9%AA%8C%E8%AF%81%E5%99%A8%E7%9A%84%E9%99%90%E5%88%B6",title:"验证器的限制",target:"_blank",rel:"noopener noreferrer"},S=n("p",null,[a("有一些不明确的情况，你需要显示处理验证，而不是依赖 "),n("code",null,"ModelSerializer"),a(" 生成的默认序列化类。")],-1),T=n("p",null,[a("在这些情况下，你可能希望通过为序列化类 "),n("code",null,"Meta.validators"),a(" 属性指定一个空列表来禁用自动生成的验证器。")],-1),V={id:"可选字段",tabindex:"-1"},R=n("a",{class:"header-anchor",href:"#可选字段","aria-hidden":"true"},"#",-1),U={href:"http://drf.jiuyou.info/#/drf/validators?id=%E5%8F%AF%E9%80%89%E5%AD%97%E6%AE%B5",title:"可选字段",target:"_blank",rel:"noopener noreferrer"},j=t(`<p>默认情况下 &quot;unique together&quot; 验证强制所有字段都是 <code>required=True</code>。在某些情况下，你可能希望显式将 <code>required=False</code> 应用于其中一个字段，在这种情况下，验证所需的行为是不明确的。</p><p>在这种情况下，你通常需要从序列化类中排除验证器，并且在 <code>.validate()</code> 方法中或在视图中显式地编写验证逻辑。</p><p>例如：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">BillingRecordSerializer</span><span class="token punctuation">(</span>serializers<span class="token punctuation">.</span>ModelSerializer<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">validate</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># Apply custom validation either here, or in the view.</span>

    <span class="token keyword">class</span> <span class="token class-name">Meta</span><span class="token punctuation">:</span>
        fields <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">&#39;client&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;date&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;amount&#39;</span><span class="token punctuation">)</span>
        extra_kwargs <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&#39;client&#39;</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">&#39;required&#39;</span><span class="token punctuation">:</span> <span class="token string">&#39;False&#39;</span><span class="token punctuation">}</span><span class="token punctuation">}</span>
        validators <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token comment"># Remove a default &quot;unique together&quot; constraint.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,4),M={id:"更新嵌套序列化类",tabindex:"-1"},I=n("a",{class:"header-anchor",href:"#更新嵌套序列化类","aria-hidden":"true"},"#",-1),N={href:"http://drf.jiuyou.info/#/drf/validators?id=%E6%9B%B4%E6%96%B0%E5%B5%8C%E5%A5%97%E5%BA%8F%E5%88%97%E5%8C%96%E7%B1%BB",title:"更新嵌套序列化类",target:"_blank",rel:"noopener noreferrer"},O=n("p",null,[a("将更新应用于现有实例时，唯一性验证器将从唯一性检查中排除当前实例。当前实例在唯一性检查的上下文中可用，因为它作为序列化程序中的一个属性存在，最初在实例化序列化类时已使用 "),n("code",null,"instance=..."),a(" 传递。")],-1),Y=n("p",null,"在嵌套序列化类上进行更新操作时，无法应用此排除，因为该实例不可用。",-1),H=n("p",null,[a("你可能又一次需要明确地从序列化类中移除验证器，并将验证约束的代码显式写入 "),n("code",null,".validate()"),a(" 方法或视图中。")],-1),P={id:"调试复杂的案例",tabindex:"-1"},L=n("a",{class:"header-anchor",href:"#调试复杂的案例","aria-hidden":"true"},"#",-1),G={href:"http://drf.jiuyou.info/#/drf/validators?id=%E8%B0%83%E8%AF%95%E5%A4%8D%E6%9D%82%E7%9A%84%E6%A1%88%E4%BE%8B",title:"调试复杂的案例",target:"_blank",rel:"noopener noreferrer"},J=t(`<p>如果你不确定 <code>ModelSerializer</code> 类的默认行为，那么运行 <code>manage.py shell</code> 并打印序列化类实例通常是一个好主意，以便你可以检查它自动生成的字段和验证器。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> serializer <span class="token operator">=</span> MyComplexModelSerializer<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token keyword">print</span><span class="token punctuation">(</span>serializer<span class="token punctuation">)</span>
<span class="token keyword">class</span> <span class="token class-name">MyComplexModelSerializer</span><span class="token punctuation">:</span>
    my_fields <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>还要记住，在复杂情况下，明确定义序列化类通常会更好，而不是依赖默认的 <code>ModelSerializer</code> 行为。虽然这样会写更多的代码，但确保了最终的行为更加透明。</p>`,3),K={id:"编写自定义验证器",tabindex:"-1"},Q=n("a",{class:"header-anchor",href:"#编写自定义验证器","aria-hidden":"true"},"#",-1),W={href:"http://drf.jiuyou.info/#/drf/validators?id=%E7%BC%96%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89%E9%AA%8C%E8%AF%81%E5%99%A8",title:"编写自定义验证器",target:"_blank",rel:"noopener noreferrer"},X=n("p",null,"你可以使用 Django 现有的验证器，也可以编写自定义验证器。",-1),Z={id:"基于函数",tabindex:"-1"},$=n("a",{class:"header-anchor",href:"#基于函数","aria-hidden":"true"},"#",-1),nn={href:"http://drf.jiuyou.info/#/drf/validators?id=%E5%9F%BA%E4%BA%8E%E5%87%BD%E6%95%B0",title:"基于函数",target:"_blank",rel:"noopener noreferrer"},an=t(`<p>验证器可以是任何可调用对象，在失败时引发 <code>serializers.ValidationError</code>。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">even_number</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> value <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>
        <span class="token keyword">raise</span> serializers<span class="token punctuation">.</span>ValidationError<span class="token punctuation">(</span><span class="token string">&#39;This field must be an even number.&#39;</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,2),sn={id:"字段级验证",tabindex:"-1"},en=n("a",{class:"header-anchor",href:"#字段级验证","aria-hidden":"true"},"#",-1),tn={href:"http://drf.jiuyou.info/#/drf/validators?id=%E5%AD%97%E6%AE%B5%E7%BA%A7%E9%AA%8C%E8%AF%81",title:"字段级验证",target:"_blank",rel:"noopener noreferrer"},on=n("p",null,[a("你可以通过向 "),n("code",null,"Serializer"),a(" 子类添加 "),n("code",null,".validate_<field_name>"),a("方法来指定自定义字段级验证。")],-1),pn={id:"基于类",tabindex:"-1"},ln=n("a",{class:"header-anchor",href:"#基于类","aria-hidden":"true"},"#",-1),rn={href:"http://drf.jiuyou.info/#/drf/validators?id=%E5%9F%BA%E4%BA%8E%E7%B1%BB",title:"基于类",target:"_blank",rel:"noopener noreferrer"},cn=t(`<p>要编写一个基于类的验证器，请使用 <code>__call__</code> 方法。基于类的验证器很有用，因为它们允许参数化和重用行为。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">MultipleOf</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> base<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>base <span class="token operator">=</span> base

    <span class="token keyword">def</span> <span class="token function">__call__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> value <span class="token operator">%</span> self<span class="token punctuation">.</span>base <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>
            message <span class="token operator">=</span> <span class="token string">&#39;This field must be a multiple of %d.&#39;</span> <span class="token operator">%</span> self<span class="token punctuation">.</span>base
            <span class="token keyword">raise</span> serializers<span class="token punctuation">.</span>ValidationError<span class="token punctuation">(</span>message<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,2),dn={id:"使用-set-context",tabindex:"-1"},un=n("a",{class:"header-anchor",href:"#使用-set-context","aria-hidden":"true"},"#",-1),kn={href:"http://drf.jiuyou.info/#/drf/validators?id=%E4%BD%BF%E7%94%A8-set_context",title:"使用 ",target:"_blank",rel:"noopener noreferrer"},hn={href:"http://drf.jiuyou.info/#/drf/validators?id=%E4%BD%BF%E7%94%A8-set_context",title:"set_context()",target:"_blank",rel:"noopener noreferrer"},vn=t(`<p>在一些高级的情况下，你可能想要在验证器中获取正在被验证的序列化字段。这时，你可以通过在基于类的验证器上声明 <code>set_context</code> 方法来完成此操作。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">set_context</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> serializer_field<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># Determine if this is an update or a create operation.</span>
    <span class="token comment"># In \`__call__\` we can then use that information to modify the validation behavior.</span>
    self<span class="token punctuation">.</span>is_update <span class="token operator">=</span> serializer_field<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>instance <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,2);function mn(fn,_n){const s=i("ExternalLinkIcon");return p(),l("div",null,[c,n("blockquote",null,[n("p",null,[n("a",d,[a("官方原文链接"),e(s)])])]),n("h1",u,[k,a(),n("a",h,[a("验证器"),e(s)])]),v,m,n("h2",f,[_,a(),n("a",b,[a("REST framework 中的验证"),e(s)])]),E,n("h4",g,[A,a(),n("a",y,[a("举个栗子"),e(s)])]),B,n("h4",F,[x,a(),n("a",w,[a("Advanced field defaults"),e(s)])]),q,n("h1",z,[D,a(),n("a",C,[a("验证器的限制"),e(s)])]),S,T,n("h2",V,[R,a(),n("a",U,[a("可选字段"),e(s)])]),j,n("h2",M,[I,a(),n("a",N,[a("更新嵌套序列化类"),e(s)])]),O,Y,H,n("h2",P,[L,a(),n("a",G,[a("调试复杂的案例"),e(s)])]),J,n("h1",K,[Q,a(),n("a",W,[a("编写自定义验证器"),e(s)])]),X,n("h2",Z,[$,a(),n("a",nn,[a("基于函数"),e(s)])]),an,n("h4",sn,[en,a(),n("a",tn,[a("字段级验证"),e(s)])]),on,n("h2",pn,[ln,a(),n("a",rn,[a("基于类"),e(s)])]),cn,n("h4",dn,[un,a(),n("a",kn,[a("使用 "),e(s)]),n("a",hn,[a("set_context()"),e(s)])]),vn])}const gn=o(r,[["render",mn],["__file","Rest-framework专栏讲解(十四)：Validators.html.vue"]]);export{gn as default};
