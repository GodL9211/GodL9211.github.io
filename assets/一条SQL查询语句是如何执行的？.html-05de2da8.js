import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r as p,o as r,c as l,a as s,b as a,e,f as o}from"./app-7702e136.js";const i="/assets/小结-24729fe7.png",c="/assets/mysql逻辑架构图-da17ce87.png",d="/assets/用户权限-316b3512.png",u="/assets/sql词法解析过程-854322f2.png",m="/assets/sql语法树-47f8ad32.png",k={},b=o('<h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言" aria-hidden="true">#</a> 前言</h2><figure><img src="'+i+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="mysql-的逻辑架构图" tabindex="-1"><a class="header-anchor" href="#mysql-的逻辑架构图" aria-hidden="true">#</a> MySQL 的逻辑架构图</h2><figure><img src="'+c+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>大体来说，MySQL 可以分为 Server 层和存储引擎层两部分。</p><ul><li><p>server层： 主要包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p></li><li><p>Store层： 存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。</p></li></ul><blockquote><p>创建表的时候可以通过<code>engine=memory</code>等指定使用的存储引擎。不同的存储引擎共用一个<code>Server</code>层。</p></blockquote><h3 id="连接器" tabindex="-1"><a class="header-anchor" href="#连接器" aria-hidden="true">#</a> 连接器</h3><p><code>navicat</code>，<code>mysql front</code>，<code>jdbc</code>，<code>SQLyog</code>等客户端要向mysql发起通信都必须先跟Server端建立通信连接，而建立连接的工作就是有连接器完成的。</p><p>第一步，你会先连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令一般是这么写的：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>mysql ‐h host<span class="token punctuation">[</span>数据库地址<span class="token punctuation">]</span> ‐u root<span class="token punctuation">[</span>用户<span class="token punctuation">]</span> ‐p root<span class="token punctuation">[</span>密码<span class="token punctuation">]</span> ‐P <span class="token number">3306</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>连接命令中的 mysql 是客户端工具，用来跟服务端建立连接。在完成经典的 TCP 握手后，连接器就要开始认证你的身份，这个时候用的就是你输入的用户名和密码。</p><ul><li>1、如果用户名或密码不对，你就会收到一个&quot;Access denied for user&quot;的错误，然后客户端程序结束执行。</li><li>2、如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。</li></ul><p>用户的权限表在系统表空间的mysql的user表中。</p><figure><img src="`+d+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><blockquote><p>修改user密码</p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>mysql<span class="token operator">&gt;</span> CREATE <span class="token environment constant">USER</span> <span class="token string">&#39;username&#39;</span>@<span class="token string">&#39;host&#39;</span> IDENTIFIED BY <span class="token string">&#39;password&#39;</span><span class="token punctuation">;</span> //创建新用户
mysql<span class="token operator">&gt;</span> grant all privileges on *.* to <span class="token string">&#39;username&#39;</span>@<span class="token string">&#39;%&#39;</span><span class="token punctuation">;</span> //赋权限,%表示所有<span class="token punctuation">(</span>host<span class="token punctuation">)</span>
mysql<span class="token operator">&gt;</span> flush privileges //刷新数据库
mysql<span class="token operator">&gt;</span> update user <span class="token builtin class-name">set</span> <span class="token assign-left variable">password</span><span class="token operator">=</span>password<span class="token punctuation">(</span>”123456″<span class="token punctuation">)</span> where <span class="token assign-left variable">user</span><span class="token operator">=</span>’root’<span class="token punctuation">;</span><span class="token punctuation">(</span>设置用户名密码<span class="token punctuation">)</span>
mysql<span class="token operator">&gt;</span> show grants <span class="token keyword">for</span> root@<span class="token string">&quot;%&quot;</span><span class="token punctuation">;</span> 查看当前用户的权限
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。</p></blockquote><p>连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在<code>show processlist</code>命令中看到它。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>+-------+------+-----------+------+---------+------+----------+------------------+----------+
<span class="token operator">|</span> Id    <span class="token operator">|</span> User <span class="token operator">|</span> Host      <span class="token operator">|</span> db   <span class="token operator">|</span> Command <span class="token operator">|</span> Time <span class="token operator">|</span> State    <span class="token operator">|</span> Info             <span class="token operator">|</span> Progress <span class="token operator">|</span>
+-------+------+-----------+------+---------+------+----------+------------------+----------+
<span class="token operator">|</span> <span class="token number">80920</span> <span class="token operator">|</span> root <span class="token operator">|</span> localhost <span class="token operator">|</span> NULL <span class="token operator">|</span> Query   <span class="token operator">|</span>    <span class="token number">0</span> <span class="token operator">|</span> starting <span class="token operator">|</span> show processlist <span class="token operator">|</span>    <span class="token number">0.000</span> <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token number">80927</span> <span class="token operator">|</span> root <span class="token operator">|</span> localhost <span class="token operator">|</span> NULL <span class="token operator">|</span> Sleep   <span class="token operator">|</span>    <span class="token number">8</span> <span class="token operator">|</span>          <span class="token operator">|</span> NULL             <span class="token operator">|</span>    <span class="token number">0.000</span> <span class="token operator">|</span>
+-------+------+-----------+------+---------+------+----------+------------------+----------+
<span class="token number">2</span> rows <span class="token keyword">in</span> <span class="token builtin class-name">set</span> <span class="token punctuation">(</span><span class="token number">0.000</span> sec<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>show processlist</code>的结果如上，其中的 Command 列显示为“Sleep”的这一行，就表示现在系统里面有一个空闲连接。</p><p>客户端如果长时间不发送command到Server端，连接器就会自动将它断开。这个时间是由参数<code>wait_timeout</code>控制的，默认值是8小时。查看wait_timeout:</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>mysql<span class="token operator">&gt;</span> show global variables like <span class="token string">&quot;wait_timeout&quot;</span><span class="token punctuation">;</span>
mysql<span class="token operator">&gt;</span> <span class="token builtin class-name">set</span> global <span class="token assign-left variable">wait_timeout</span><span class="token operator">=</span><span class="token number">28800</span><span class="token punctuation">;</span> 设置全局服务器关闭非交互连接之前等待活动的秒数
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>开发当中我们大多数时候用的都是长连接,把连接放在Pool内进行管理，但是长连接有些时候会导致 MySQL 占用内存涨得特别快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。</p><p>怎么解决这类问题呢？</p><ul><li>1、定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</li><li>2、如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</li></ul><h3 id="查询缓存" tabindex="-1"><a class="header-anchor" href="#查询缓存" aria-hidden="true">#</a> 查询缓存</h3><p>连接建立完成后，你就可以执行<code>select</code>等语句了。执行逻辑就会来到第二步：查询缓存。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>mysql<span class="token operator">&gt;</span>show databases<span class="token punctuation">;</span> 显示所有数据库
mysql<span class="token operator">&gt;</span>use dbname； 打开数据库：
mysql<span class="token operator">&gt;</span>show tables<span class="token punctuation">;</span> 显示数据库mysql中所有的表；
mysql<span class="token operator">&gt;</span>describe user<span class="token punctuation">;</span> 显示表mysql数据库中user表的列信息）；
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。key 是查询的语句，value 是查询的结果。如果你的查询能够直接在这个缓存中找到 key，那么这个 value 就会被直接返回给客户端。</p><p>如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。你可以看到，如果查询命中缓存，MySQL 不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。</p><p>但是大多数情况下我会建议你不要使用查询缓存，为什么呢？</p><p>因为查询缓存往往弊大于利。查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。</p><p>好在 MySQL 也提供了这种“按需使用”的方式。你可以将my.cnf参数query_cache_type 设置成 DEMAND。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># my.cnf</span>
<span class="token comment"># query_cache_type有3个值: 0代表关闭查询缓存OFF，1代表开启ON，2（DEMAND）代表当sql语句中有SQL_CACHE关键词时才缓存</span>
<span class="token assign-left variable">query_cache_type</span><span class="token operator">=</span><span class="token number">2</span>  <span class="token comment"># 这样对于默认的 SQL 语句都不使用</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样对于默认的 SQL 语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用 SQL_CACHE 显式指定，像下面这个语句一样：</p><div class="language-SQL line-numbers-mode" data-ext="SQL"><pre class="language-SQL"><code>mysql&gt; select SQL_CACHE * from test where ID=5；
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>查看当前mysql实例是否开启缓存机制</p><div class="language-SQL line-numbers-mode" data-ext="SQL"><pre class="language-SQL"><code>mysql&gt; show global variables like &quot;%query_cache_type%&quot;;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>监控查询缓存的命中率:</p><div class="language-SQL line-numbers-mode" data-ext="SQL"><pre class="language-SQL"><code>mysql&gt; show status like&#39;%Qcache%&#39;; //查看运行的缓存信息
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>+-------------------------+---------+
<span class="token operator">|</span> Variable_name           <span class="token operator">|</span> Value   <span class="token operator">|</span>
+-------------------------+---------+
<span class="token operator">|</span> Qcache_free_blocks      <span class="token operator">|</span> <span class="token number">1</span>       <span class="token operator">|</span>
<span class="token operator">|</span> Qcache_free_memory      <span class="token operator">|</span> <span class="token number">1031272</span> <span class="token operator">|</span>
<span class="token operator">|</span> Qcache_hits             <span class="token operator">|</span> <span class="token number">0</span>       <span class="token operator">|</span>
<span class="token operator">|</span> Qcache_inserts          <span class="token operator">|</span> <span class="token number">0</span>       <span class="token operator">|</span>
<span class="token operator">|</span> Qcache_lowmem_prunes    <span class="token operator">|</span> <span class="token number">0</span>       <span class="token operator">|</span>
<span class="token operator">|</span> Qcache_not_cached       <span class="token operator">|</span> <span class="token number">0</span>       <span class="token operator">|</span>
<span class="token operator">|</span> Qcache_queries_in_cache <span class="token operator">|</span> <span class="token number">0</span>       <span class="token operator">|</span>
<span class="token operator">|</span> Qcache_total_blocks     <span class="token operator">|</span> <span class="token number">1</span>       <span class="token operator">|</span>
+-------------------------+---------+
<span class="token number">8</span> rows <span class="token keyword">in</span> <span class="token builtin class-name">set</span> <span class="token punctuation">(</span><span class="token number">0.000</span> sec<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>Qcache_free_blocks:表示查询缓存中目前还有多少剩余的blocks，如果该值显示较大，则说明查询缓存中的内存碎片过多了，可能在一定的时间进行整理。</li><li>Qcache_free_memory:查询缓存的内存大小，通过这个参数可以很清晰的知道当前系统的查询内存是否够用，是多了，还是不够用，DBA可以根据实际情况做出调整。</li><li>Qcache_hits:表示有多少次命中缓存。我们主要可以通过该值来验证我们的查询缓存的效果。数字越大，缓存效果越理想。</li><li>Qcache_inserts: 表示多少次未命中然后插入，意思是新来的SQL请求在缓存中未找到，不得不执行查询处理，执行查询处理后把结果insert到查询缓存中。这样的情况的次数，次数越多，表示查询缓存应用到的比较少，效果也就不理想。当然系统刚启动后，查询缓存是空的，这很正常。</li><li>Qcache_lowmem_prunes:该参数记录有多少条查询因为内存不足而被移除出查询缓存。通过这个值，用户可以适当的调整缓存大小。</li><li>Qcache_not_cached: 表示因为query_cache_type的设置而没有被缓存的查询数量。</li><li>Qcache_queries_in_cache:当前缓存中缓存的查询数量。Qcache_total_blocks:当前缓存的block数量。</li></ul><blockquote><p>MySQL 8.0 版本直接将查询缓存的整块功能删掉了。</p></blockquote><h3 id="分析器" tabindex="-1"><a class="header-anchor" href="#分析器" aria-hidden="true">#</a> 分析器</h3><p>如果没有命中查询缓存，就要开始真正执行语句了。首先，MySQL 需要知道你要做什么，因此需要对 SQL 语句做解析。</p><p>分析器先会做“词法分析”。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。</p><p>MySQL 从你输入的&quot;select&quot;这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”。</p><p>做完了这些识别以后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。</p><p>如果你的语句不对，就会收到“<code>You have an error in your SQL syntax</code>”的错误提醒，比如下面这个语句 from 写成了&quot;rom&quot;。</p><div class="language-SQL line-numbers-mode" data-ext="SQL"><pre class="language-SQL"><code>mysql&gt; select * fro test where id=1;
ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;fro test where id=1&#39; at line 1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="词法分析器原理" tabindex="-1"><a class="header-anchor" href="#词法分析器原理" aria-hidden="true">#</a> 词法分析器原理</h4><p>词法分析器分成6个主要步骤完成对sql语句的分析</p><blockquote><p>1、词法分析<br> 2、语法分析<br> 3、语义分析<br> 4、构造执行树<br> 5、生成执行计划<br> 6、计划的执行</p></blockquote><p>下图是SQL词法分析的过程步骤：</p><figure><img src="`+u+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',56),v={href:"https://en.wikipedia.org/wiki/LR_parser%E3%80%82%E9%82%A3%E4%B9%88%E9%99%A4%E4%BA%86Bison%E5%A4%96%EF%BC%8CJava%E5%BD%93%E4%B8%AD%E4%B9%9F%E6%9C%89%E5%BC%80%E6%BA%90%E7%9A%84%E8%AF%8D%E6%B3%95%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E4%BE%8B%E5%A6%82Antlr4%EF%BC%8CANTLR%E4%BB%8E%E8%AF%AD%E6%B3%95%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA%E8%A7%A3%E6%9E%90%E5%99%A8%EF%BC%8C%E5%8F%AF%E4%BB%A5%E6%9E%84%E5%BB%BA%E5%92%8C%E9%81%8D%E5%8E%86%E8%A7%A3%E6%9E%90%E6%A0%91%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%9C%A8IDEA%E5%B7%A5%E5%85%B7%E5%BD%93%E4%B8%AD%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6%EF%BC%9Aantlr",target:"_blank",rel:"noopener noreferrer"},h=o('<p>经过bison语法分析之后，会生成一个这样的语法树:</p><figure><img src="'+m+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>至此我们分析器的工作任务也基本圆满了。接下来进入到优化器</p><h3 id="优化器" tabindex="-1"><a class="header-anchor" href="#优化器" aria-hidden="true">#</a> 优化器</h3><p>经过了分析器，MySQL 就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。</p><p>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的 join：</p><div class="language-SQL line-numbers-mode" data-ext="SQL"><pre class="language-SQL"><code>mysql&gt; select * from test1 join test2 using(ID) where test1.name=yangguo and test2.name=xiaol
ongnv;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>既可以先从表 test1 里面取出 name=yangguo的记录的 ID 值，再根据 ID 值关联到表 test2，再判断 test2 里面 name的值是否等于 yangguo。</p><p>也可以先从表 test2 里面取出 name=xiaolongnv 的记录的 ID 值，再根据 ID 值关联到 test1，再判断 test1 里面 name的值是否等于 yangguo。</p><p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。如果你还有一些疑问，比如优化器是怎么选择索引的，有没有可能选择错等等。</p><h3 id="执行器" tabindex="-1"><a class="header-anchor" href="#执行器" aria-hidden="true">#</a> 执行器</h3><p>开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误，如下所示 (在<br> 工程实现上，如果命中查询缓存，会在查询缓存返回结果的时候，做权限验证。查询也会在优化器之前调用 precheck 验证权<br> 限)。</p><div class="language-SQL line-numbers-mode" data-ext="SQL"><pre class="language-SQL"><code>mysql&gt; select * from test where id=1;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。比如我们这个例子中的表 test 中，ID 字段没有索引，那么执行器的执行流程是这样的：</p><ol><li>调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；</li><li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</li><li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li></ol><p>至此，这个语句就执行完成了。对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。你会在数据库的慢查询日志中看到一个rows_examined 的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟 rows_examined 并不是完全相同的。</p><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考" aria-hidden="true">#</a> 参考</h2>`,17),g={href:"https://time.geekbang.org/column/article/68319",target:"_blank",rel:"noopener noreferrer"};function _(y,E){const n=p("ExternalLinkIcon");return r(),l("div",null,[b,s("p",null,[a("SQL语句的分析分为词法分析与语法分析，mysql的词法分析由MySQLLex[MySQL自己实现的]完成，语法分析由Bison生成。关于语法树大家如果想要深入研究可以参考这篇wiki文章："),s("a",v,[a("https://en.wikipedia.org/wiki/LR_parser。那么除了Bison外，Java当中也有开源的词法结构分析工具例如Antlr4，ANTLR从语法生成一个解析器，可以构建和遍历解析树，可以在IDEA工具当中安装插件：antlr"),e(n)]),a(" v4 grammar plugin。")]),h,s("blockquote",null,[s("p",null,[s("a",g,[a("https://time.geekbang.org/column/article/68319"),e(n)])])])])}const L=t(k,[["render",_],["__file","一条SQL查询语句是如何执行的？.html.vue"]]);export{L as default};
