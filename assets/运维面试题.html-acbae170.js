import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{o as s,c as e,f as n}from"./app-86c4e386.js";const r="/assets/Snipaste_2023-12-13_11-11-46-cdad1cfc.png",i="/assets/lvs-nat-b202c45c.png",l="/assets/lvs-dr-efb99376.png",p={},t=n(`<h2 id="_1-磁盘使用率检测-用shell脚本" tabindex="-1"><a class="header-anchor" href="#_1-磁盘使用率检测-用shell脚本" aria-hidden="true">#</a> 1. 磁盘使用率检测（用shell脚本）</h2><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token shebang important">#!/bin/bash</span>
<span class="token comment"># 截取IP</span>
<span class="token assign-left variable">IP</span><span class="token operator">=</span><span class="token variable"><span class="token variable">\`</span><span class="token function">ifconfig</span> eth0 <span class="token operator">|</span> <span class="token function">awk</span> <span class="token parameter variable">-F</span> <span class="token string">&quot; &quot;</span> <span class="token string">&#39;NR==2{print $2}&#39;</span><span class="token variable">\`</span></span>
<span class="token comment"># 定义使用率,并转换为数字</span>
<span class="token assign-left variable">SPACE</span><span class="token operator">=</span><span class="token variable"><span class="token variable">\`</span><span class="token function">df</span> <span class="token parameter variable">-Ph</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">&#39;{print int($5)}&#39;</span><span class="token variable">\`</span></span>
<span class="token keyword">for</span> <span class="token for-or-select variable">i</span> <span class="token keyword">in</span> <span class="token variable">$SPACE</span>
    <span class="token keyword">do</span>
    <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$i</span> <span class="token parameter variable">-ge</span> <span class="token number">90</span> <span class="token punctuation">]</span>
        <span class="token keyword">then</span>
        <span class="token builtin class-name">echo</span> <span class="token string">&quot;<span class="token variable">$IP</span>的磁盘使用率已经超过了90%，请及时处理&quot;</span>
    <span class="token keyword">fi</span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;<span class="token variable">$IP</span>的磁盘使用率不超过了90% ~&quot;</span>
    <span class="token keyword">done</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_2-lvs-负载均衡有哪些策略" tabindex="-1"><a class="header-anchor" href="#_2-lvs-负载均衡有哪些策略" aria-hidden="true">#</a> 2. LVS 负载均衡有哪些策略？</h2><p>LVS一共有三种工作模式： DR，Tunnel，NAT</p><h2 id="_3-谈谈你对lvs的理解" tabindex="-1"><a class="header-anchor" href="#_3-谈谈你对lvs的理解" aria-hidden="true">#</a> 3. 谈谈你对LVS的理解？</h2><p>LVS是一个虚拟的服务器集群系统，在unix系统下实现负载均衡的功能；采用IP负载均衡技术和机遇内容请求分发技术来实现。</p><p>LVS采用三层结构，分别是：</p><ul><li>第一层： 负载调度器</li><li>第二层： 服务池</li><li>第三层：共享存储</li></ul><p>负载调度器（load balancer/ Director），是整个集群的总代理，它有两个网卡，一个网卡面对访问网站的客户端，一个网卡面对整个集群的内部。负责将客户端的请求发送到一组服务器上执行，而客户也认为服务是来自这台主的。</p><p>举个生动的例子，集群是个公司，负载调度器就是在外接揽生意，将接揽到的生意分发给后台的真正干活的真正的主机们。当然需要将活按照一定的算法分发下去，让大家都公平的干活。<br> 服务器池（server pool/ Realserver），是一组真正执行客户请求的服务器，可以当做WEB服务器。就是上面例子中的小员工。<br> 共享存储（shared storage），它为服务器池提供一个共享的存储区，这样很容易使得服务器池拥有相同的内容，提供相同的服务。</p><p>一个公司得有一个后台账目吧，这才能协调。不然客户把钱付给了A，而换B接待客户，因为没有相同的账目。B说客户没付钱，那这样就不是客户体验度的问题了。</p><figure><img src="`+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="_4-负载均衡的原理是什么" tabindex="-1"><a class="header-anchor" href="#_4-负载均衡的原理是什么" aria-hidden="true">#</a> 4. 负载均衡的原理是什么？</h2><p>当客户端发起请求时，请求直接发给Director Server（调度器），这时会根据设定的调度算法，将请求按照算法的规定智能的分发到真正的后台服务器。以达到将压力均摊。</p><p>但是我们知道，http的连接时无状态的，假设这样一个场景，我登录某宝买东西，当我看上某款商品时，我将它加入购物车，但是我刷新了一下页面，这时由于负载均衡的原因，调度器又选了新的一台服务器为我提供服务，我刚才的购物车内容全都不见了，这样就会有十分差的用户体验。</p><p>所以就还需要一个存储共享，这样就保证了用户请求的数据是一样的。</p><h2 id="_5-lvs由哪两部分组成的" tabindex="-1"><a class="header-anchor" href="#_5-lvs由哪两部分组成的" aria-hidden="true">#</a> 5. LVS由哪两部分组成的？</h2><p>LVS 由2部分程序组成，包括 ipvs 和 ipvsadm。</p><ul><li>1.ipvs(ip virtual server)：一段代码工作在内核空间，叫ipvs，是真正生效实现调度的代码。</li><li><ol start="2"><li>ipvsadm：另外一段是工作在用户空间，叫ipvsadm，负责为ipvs内核框架编写规则，定义谁是集群服务，而谁是后端真实的服务器(Real Server)</li></ol></li></ul><h2 id="_6-与lvs相关的术语有哪些" tabindex="-1"><a class="header-anchor" href="#_6-与lvs相关的术语有哪些" aria-hidden="true">#</a> 6. 与lvs相关的术语有哪些？</h2><p>DS：Director Server。指的是前端负载均衡器节点。<br> RS：Real Server。后端真实的工作服务器。<br> VIP：Virtual IP 向外部直接面向用户请求，作为用户请求的目标的IP地址。<br> DIP：Director Server IP，主要用于和内部主机通讯的IP地址。<br> RIP：Real Server IP，后端服务器的IP地址。<br> CIP：Client IP，访问客户端的IP地址。</p><h2 id="_7-lvs-nat模式的原理" tabindex="-1"><a class="header-anchor" href="#_7-lvs-nat模式的原理" aria-hidden="true">#</a> 7. LVS-NAT模式的原理</h2><figure><img src="'+i+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>(a). 当用户请求到达Director Server，此时请求的数据报文会先到内核空间的PREROUTING链。此时报文的源IP为CIP，目标IP为VIP。</p><p>(b). PREROUTING检查发现数据包的目标IP是本机，将数据包送至INPUT链。</p><p>(c). IPVS比对数据包请求的服务是否为集群服务，若是，修改数据包的目标IP地址为后端服务器IP， 然后将数据包发至POSTROUTING链。 此时报文的源IP为CIP，目标IP为RIP。</p><p>(d). POSTROUTING链通过选路，将数据包发送给Real Server。</p><p>(e). Real Server比对发现目标为自己的IP，开始构建响应报文发回给Director Server。 此时报文的源IP为RIP，目标IP为CIP。</p><p>(f). Director Server在响应客户端前，此时会将源IP地址修改为自己的VIP地址，然后响应给客户端。 此时报文的源IP为VIP，目标IP为CIP。</p><h2 id="_8-lvs-nat模型的特性" tabindex="-1"><a class="header-anchor" href="#_8-lvs-nat模型的特性" aria-hidden="true">#</a> 8. LVS-NAT模型的特性</h2><ul><li>RS应该使用私有地址，RS的网关必须指向DIP</li><li>DIP和RIP必须在同一个网段内</li><li>请求和响应报文都需要经过Director Server，高负载场景中，Director Server易成为性能瓶颈</li><li>支持端口映射</li><li>RS可以使用任意操作系统</li><li>缺陷：对Director Server压力会比较大，请求和响应都需经过director server</li></ul><h2 id="_9-lvs-dr模式原理" tabindex="-1"><a class="header-anchor" href="#_9-lvs-dr模式原理" aria-hidden="true">#</a> 9. LVS-DR模式原理</h2><figure><img src="'+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>(a) 当用户请求到达Director Server，此时请求的数据报文会先到内核空间的PREROUTING链。 此时报文的源IP为CIP，目标IP为VIP</p><p>(b) PREROUTING检查发现数据包的目标IP是本机，将数据包送至INPUT链</p><p>(c) IPVS比对数据包请求的服务是否为集群服务，若是，将请求报文中的源MAC地址修改为DIP的MAC地址，将目标MAC地址修改RIP的MAC地址，然后将数据包发至POSTROUTING链。 此时的源IP和目的IP均未修改，仅修改了源MAC地址为DIP的MAC地址，目标MAC地址为RIP的MAC地址</p><p>(d) 由于DS和RS在同一个网络中，所以是通过二层来传输。POSTROUTING链检查目标MAC地址为RIP的MAC地址，那么此时数据包将会发至Real Server。</p><p>(e) RS发现请求报文的MAC地址是自己的MAC地址，就接收此报文。处理完成之后，将响应报文通过lo接口传送给eth0网卡然后向外发出。 此时的源IP地址为VIP，目标IP为CIP</p><p>(f) 响应报文最终送达至客户端</p>',39),o=[t];function c(d,v){return s(),e("div",null,o)}const I=a(p,[["render",c],["__file","运维面试题.html.vue"]]);export{I as default};
