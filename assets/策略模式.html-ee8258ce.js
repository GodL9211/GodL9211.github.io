import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as i,f as t}from"./app-d263494b.js";const o="/assets/什么时候干掉if-3d2e0cbf.png",c="/assets/阿里巴巴消除if-b82098a7.jpg",r="/assets/登录策略-693133e5.jpg",d={},n=t('<h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言" aria-hidden="true">#</a> 前言</h2><p>在实际的项目开发中，<code>策略模式(Strategy Design Pattern)也比较常用</code>。最常见的应用场景是，利用它来<code>避免冗长的 if-else 或 switch 分支判断。</code></p><p>我们生活中的场景：</p><ul><li>买东西结账：可以使用微信支付、支付宝支付或者银行卡支付，这些交易方式就是不同的策略。</li><li>登录APP：可以使用QQ登录、微信登录、微博登录等，这些不同的登录在后台看来也需要不同的处理策略。</li><li>告警功能：根据不同的告警策略发送告警信息，如钉钉通知，微信通知等。</li></ul><p>在《阿里巴巴Java开发手册》中有提到当超过 3 层的 if-else 的逻辑判断代码可以使用策略模式来实现，这在python中同样适用。</p><figure><img src="'+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><code>错了，是下面这个！</code></p><figure><img src="'+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>策略模式定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。策略模式可以使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）。</p><p>策略模式主要的作用是解耦策略的定义、创建和使用，控制代码的复杂度，让每个部分都不至于过于复杂、代码量过多。除此之外，对于复杂代码来说，策略模式还能让其满足开闭原则，添加新策略的时候，最小化、集中化代码改动，减少引入 bug 的风险。</p><blockquote><p>工厂模式是解耦对象的创建和使用，观察者模式是解耦观察者和被观察者。策略模式跟两者类似，也能起到解耦的作用，不过，它解耦的是<code>策略的定义</code>、<code>创建</code>、<code>使用</code>这三部分。所以一般实现上都是策略模式+工厂方法模式优化。</p></blockquote><h2 id="策略的定义" tabindex="-1"><a class="header-anchor" href="#策略的定义" aria-hidden="true">#</a> 策略的定义</h2><p>策略类的定义比较简单，包含一个策略接口和一组实现这个接口的策略类。</p><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>因为所有的策略类都实现相同的接口，所以，客户端代码基于接口而非实现编程，可以灵活地替换不同的策略。</p><h2 id="策略的创建" tabindex="-1"><a class="header-anchor" href="#策略的创建" aria-hidden="true">#</a> 策略的创建</h2><h2 id="策略的使用" tabindex="-1"><a class="header-anchor" href="#策略的使用" aria-hidden="true">#</a> 策略的使用</h2>',17),s=[n];function p(l,h){return a(),i("div",null,s)}const g=e(d,[["render",p],["__file","策略模式.html.vue"]]);export{g as default};
