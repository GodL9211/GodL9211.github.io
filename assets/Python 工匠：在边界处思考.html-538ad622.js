import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r as p,o,c,a as s,b as n,e,f as l}from"./app-d1a619f2.js";const i={},u=l(`<h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言" aria-hidden="true">#</a> 前言</h2><p>2016 年，Linux 操作系统的创造者 Linus Torvalds 参加了一场<code>TED访谈节目</code>[1]。</p><p>整个节目的前半部分，主要是他在讲如何在家光着膀子写出<code>Linux</code>的故事，没有涉及太多编程相关的事情。</p><p>不过在访谈快结束时，突然出现了一个有趣的环节。主持人向 Linus 提问道：“你曾说过更愿意和那些有着好的 代码品味 的人共事，那在你眼里，什么才是好的代码品味？”</p><p>为了解释这个问题，Linus 在大屏幕上展示了一份代码。我把其摘抄如下。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token function">remove_list_entry</span><span class="token punctuation">(</span>entry<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    prev <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    walk <span class="token operator">=</span> head<span class="token punctuation">;</span>

    <span class="token comment">// 遍历链表</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>walk <span class="token operator">!=</span> entry<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        prev <span class="token operator">=</span> walk<span class="token punctuation">;</span>
        walk <span class="token operator">=</span> walk<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 关键：当要删除时，判断当前位置是否在链表头部进行不同的动作</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>prev<span class="token punctuation">)</span>
        head <span class="token operator">=</span> entry<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        prev<span class="token operator">-&gt;</span>next <span class="token operator">=</span> entry<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>函数<code>remove_list_entry</code>的主要功能是通过遍历链表，删除里面的某个成员。但在这份代码中，存在一个 <code>边界情况（Edge Case）</code>[2]。</p><blockquote><p>在编程时，<code>边界情况</code>是指那些只在极端情景下出现的情况。</p></blockquote><p>比如在上面的代码里，当我们要找的元素刚好处于链表头部时，就是一个边界情况。为了处理它，函数在删除前进行了一次<code>if / else</code>判断。</p><p>Linus 认为这条 if 语句是整段代码的<code>坏味道</code>来源，写出它的人代码品味不够好 ☹️。</p><p>那么，一个品味更好的人应该怎么写呢？很快，屏幕上出现了第二份代码。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token function">remove_list_entry</span><span class="token punctuation">(</span>entry<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    indirect <span class="token operator">=</span> <span class="token operator">&amp;</span>head

    <span class="token comment">// 遍历链表过程代码已省略</span>

    <span class="token comment">// 当要删除时，直接进行指针操作删除</span>
    <span class="token operator">*</span>indirect <span class="token operator">=</span> entry<span class="token operator">-&gt;</span>next
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在新代码中，remove_list_entry 函数利用了 C 语言里的指针特性，把之前的<code>if / else</code>完全消除了。无论待删除的目标是在链表头部还是中间，函数都能一视同仁的完成删除操作。</p><blockquote><p>之前的边界情况消失了。</p></blockquote><p>看到这你是不是在犯嘀咕：Python 又没有指针，你跟我说这么多指针不指针的干啥？</p><p>虽然 Python 没有指针，但我觉得这个例子为我们提供了一个很有趣的主题。那就是<code>如何充分利用语言特性，更好的处理编码时的边界情况。</code></p><p>我认为，好代码在处理边界情况时应该是简洁的、<code>润物细无声</code>的。</p><p>就像上面的例子一样，可以做到让边界情况消融在代码主流程中。在写 Python 时，有不少编码技巧和惯例可以帮我们做到这一点，一块来看看吧。</p><h2 id="第一课-使用分支还是异常" tabindex="-1"><a class="header-anchor" href="#第一课-使用分支还是异常" aria-hidden="true">#</a> 第一课：使用分支还是异常？</h2><p>今天周末，你计划参加朋友组织的聚餐，临出门时突然想起来最近是雨季。于是你掏出手机打开天气 App，看看今天是不是会下雨。如果下雨，就带上一把伞再出门。</p><p>假如把<code>今天下雨</code>类比成编程时的边界情况，那<code>看天气预报 + 带伞</code>就是我们的边界处理代码。</p><p>这种<code>if 下雨 then 带伞</code>的分支式判断，基本是一种来自直觉的思考本能。</p><p>所以，当我们在编程时发现边界情况时，第一反应往往就是：<code>弄个if分支把它包起来吧!</code>。</p><p>比如下面这段代码：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">counter_ap</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">&quot;&quot;&quot;计算列表里面每个元素出现的数量&quot;&quot;&quot;</span>
    result <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">for</span> key <span class="token keyword">in</span> l<span class="token punctuation">:</span>
        <span class="token comment"># 主流程：累加计数器</span>
        <span class="token keyword">if</span> key <span class="token keyword">in</span> result<span class="token punctuation">:</span>
            result<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>
        <span class="token comment"># 边界情况：当元素第一次出现时，先初始化值为1</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            result<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token keyword">return</span> result

<span class="token comment"># 执行结果：</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>counter_ap<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&#39;apple&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;banana&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;apple&#39;</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment"># {&#39;apple&#39;: 2, &#39;banana&#39;: 1}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的循环里，代码的主流程是<code>对每个 key 的计数器加 1</code>。但是，当<code>result</code>字典里还没有<code>key</code>元素时，是不能直接进行累加操作的（会抛出 KeyError）。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> result <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> result<span class="token punctuation">[</span><span class="token string">&#39;foo&#39;</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">&quot;&lt;stdin&gt;&quot;</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">&gt;</span>
KeyError<span class="token punctuation">:</span> <span class="token string">&#39;foo&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>于是一个边界情况出现了：<code>当元素第一次出现时，我们需要对值进行初始化。</code></p><p>所以，我专门写了一条<code>if</code>语句去处理这个边界情况。代码简单，无需过多解释。但你可能不知道的是，其实有一个术语来专门描述这种编程风格：<code>（LBYL）Look Before You Leap</code>。</p><p><code>LBYL</code> 这缩写不太好翻译。用大白话讲，就是在进行操作前，先对可能的边界情况进行条件判断。根据结果不同，确定是处理边界情况，还是执行主流程。</p><p>如之前所说，使用<code>LBYL</code>来处理边界情况，几乎是一种直觉式的行为。<code>有边界情况，就加上 if 分支</code>和<code>如果天气预报说下雨，我就带伞出门</code>一样，是一种基本不需要过脑子的操作。</p><p>而在<code>LBYL</code>之外，有着与其形成鲜明对比的另外一种风格：<code>EAFP（Easier to Ask for Forgiveness than Permission)</code>。</p><h3 id="获取原谅比许可简单-eafp" tabindex="-1"><a class="header-anchor" href="#获取原谅比许可简单-eafp" aria-hidden="true">#</a> 获取原谅比许可简单(EAFP)</h3><p><code>EAFP</code>通常被翻译成<code>获取原谅比许可简单</code>。如果还用下雨举例，那 EAFP 的做法就类似于<code>出门前不看任何天气预报，如果淋雨了，就回家后洗澡吃感冒药 💊</code>。</p><p>使用<code>EAFP</code>风格的代码是这样的：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">counter_af</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">:</span>
    result <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">for</span> key <span class="token keyword">in</span> l<span class="token punctuation">:</span>
        <span class="token keyword">try</span><span class="token punctuation">:</span>
            <span class="token comment"># 总是直接执行主流程：累加计数器</span>
            result<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>
        <span class="token keyword">except</span> KeyError<span class="token punctuation">:</span>
            <span class="token comment"># 边界情况：当元素第一次出现时会报错 KeyError，此时进行初始化</span>
            result<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token keyword">return</span> result
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>和<code>LBYL</code>相比，<code>EAFP</code>编程风格更为简单粗暴。它总是直奔主流程而去，把边界情况都放在异常处理<code>try except</code>块内消化掉。</p><p>如果你问我：“这两种编程风格哪个更好？”，我只能说整个 Python 社区对基于异常捕获的“请求原谅（EAFP）”型编程风格有着明显的偏爱。其中的原因有很多。</p><p>首先，和许多其他编程语言不同，在 Python 里抛出异常是一个很轻量的操作，即使程序会大量抛出、捕获异常，使用<code>EAFP</code>也不会给程序带来额外的负担。</p><p>其次，“请求原谅”在性能上通常也更有优势，因为程序总是直奔主流程而去，只有极少数情况下才需要处理边界情况。</p><p>拿上面的例子来说，第二段代码通常会比第一段更快，因为它不用在每次循环时都做一次额外的成员检查。</p><blockquote><p>Hint：如果你想了解更多这方面的知识，建议阅读： Write Cleaner Python: Use Exceptions[3]</p></blockquote><p>所以，每当你想凭直觉写下<code>if else</code>来处理边界情况时，先考虑下使用<code>try</code>来捕获异常是不是更合适。毕竟，Pythonista 们总是喜欢“吃感冒药 💊”胜过“看天气预报”。😅</p><h2 id="当容器内容不存在时" tabindex="-1"><a class="header-anchor" href="#当容器内容不存在时" aria-hidden="true">#</a> 当容器内容不存在时</h2><p>Python 里有很多内建的容器类型，比如字典、列表、集合等等。在进行容器操作时，经常会出现一些边界情况。其中<code>要访问的内容不存在</code>，是最为常见的一类：</p><ul><li>操作字典时，访问的键<code>key</code>不存在，会抛出<code>KeyError</code>异常</li><li>操作列表、元组时，访问的下标<code>index</code>不存在，会抛出<code>IndexError</code>异常</li></ul><p>对于这类边界情况，除了针对性的捕获对应异常外，还有许多其他处理方式。</p><h3 id="使用-defaultdict-改写示例" tabindex="-1"><a class="header-anchor" href="#使用-defaultdict-改写示例" aria-hidden="true">#</a> 使用 defaultdict 改写示例</h3><p>在前面的例子里，我们使用了<code>try except</code>语句处理了“key 第一次出现”这个边界情况。虽然我说过，使用 <code>try</code>的代码比<code>if</code>更好，但这不代表它就是一份地道的Python代码。</p><p>为什么？因为如果你想统计列表元素的话，直接用<code>collections.defaultdict</code>就可以了：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">from</span> collections <span class="token keyword">import</span> defaultdict


<span class="token keyword">def</span> <span class="token function">counter_by_collections</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">:</span>
    result <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> key <span class="token keyword">in</span> l<span class="token punctuation">:</span>
        result<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>
    <span class="token keyword">return</span> result
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样的代码既不用“获取许可”，也无需“请求原谅”。 整个函数只有一个主流程，代码更清晰、更自然。</p><p>为什么<code>defaultdict</code>可以让边界情况消失？因为究其根本，之前的代码就是少了针对 “键不存在” 时的默认处理逻辑。所以，当我们用<code>defaultdict</code>声明了如何处理这个边界情况时，原本需要手动判断的部分就消失了。</p><blockquote><p>Hint：就上面的例子来说，使用<code>collections.Counter</code>[4] 也能达到同样的目的。</p></blockquote><h3 id="使用-setdefault-取值并修改" tabindex="-1"><a class="header-anchor" href="#使用-setdefault-取值并修改" aria-hidden="true">#</a> 使用 setdefault 取值并修改</h3><p>有时候，我们需要操作字典里的某个值，但它又可能并不存在。比如下面这个例子：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token comment"># 往字典的 values 键追加新值，假如不存在，先以列表初始化</span>
<span class="token keyword">try</span><span class="token punctuation">:</span>
    d<span class="token punctuation">[</span><span class="token string">&#39;values&#39;</span><span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>value<span class="token punctuation">)</span>
<span class="token keyword">except</span> KeyError<span class="token punctuation">:</span>
    d<span class="token punctuation">[</span><span class="token string">&#39;values&#39;</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>value<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>针对这种情况，我们可以使用<code>d.setdefault(key, default=None)</code>方法来简化边界处理逻辑，直接替换上面的异常捕获语句：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token comment"># 如果 setdefault 指定的 key（此处为 &quot;values&quot;）不存在，以 [] 初始化，否则返回已存在</span>
<span class="token comment"># 的值。</span>
d<span class="token punctuation">.</span>setdefault<span class="token punctuation">(</span><span class="token string">&#39;values&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>value<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>Hint：使用<code>defaultdict(list)</code>同样可以利索的解决这个问题。</p></blockquote><h3 id="使用-dict-pop-删除不存在的键" tabindex="-1"><a class="header-anchor" href="#使用-dict-pop-删除不存在的键" aria-hidden="true">#</a> 使用 dict.pop 删除不存在的键</h3><p>如果我们要删除字典的某个<code>key</code>，一般会使用<code>del</code>关键字。但当<code>key</code>不存在时，删除操作就会抛出<code>KeyError</code>异常。</p><p>所以，想要安全删除某个<code>key</code>，还得加上一段异常捕获逻辑。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">try</span><span class="token punctuation">:</span>
    <span class="token keyword">del</span> d<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
<span class="token keyword">except</span> KeyError<span class="token punctuation">:</span>
    <span class="token comment"># 忽略 key 不存在的情况</span>
    <span class="token keyword">pass</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但假设只是单纯的想删除某个<code>key</code>，并不关心它是否存在、有没有删成功。使用<code>dict.pop(key, default)</code>方法就够了。</p><p>只要在调用<code>dict.pop</code>方法时传入默认值，<code>key</code>不存在时就不会抛出异常了。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token comment"># 使用 pop 方法，指定 default 值为 None，当 key 不存在时，不会报错</span>
d<span class="token punctuation">.</span>pop<span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>Hint：严格来说，<code>pop</code>方法的主要用途并不是去删除某个<code>key</code>，而是取出某个<code>key</code>对应的值。不过我觉得偶尔用它来做删除也无伤大雅。</p></blockquote><h3 id="当列表切片越界时" tabindex="-1"><a class="header-anchor" href="#当列表切片越界时" aria-hidden="true">#</a> 当列表切片越界时</h3><p>所有人都知道，当你的列表（或元组）只有<code>3</code>个元素，而你想要访问第<code>4</code>个时，解释器会报出<code>IndexError</code>错误。我们通常称这类错误为<code>数组越界</code>。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> l <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> l<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>
<span class="token number">3</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> l<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">&quot;&lt;stdin&gt;&quot;</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">&gt;</span>
IndexError<span class="token punctuation">:</span> <span class="token builtin">list</span> index out of <span class="token builtin">range</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但你可能不知道的是，假如你请求的不是某一个元素，而是一段范围的切片。那么无论你指定的范围是否有效，程序都只会返回一个空列表<code>[]</code>，而不会抛出任何错误：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> l <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> l<span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">:</span><span class="token number">1001</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>了解了这点后，你会发现像下面这种边界处理代码根本没有必要：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">sum_list</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> limit<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">&quot;&quot;&quot;对列表的前 limit 个元素求和
    &quot;&quot;&quot;</span>
    <span class="token comment"># 如果 limit 过大，设置为数组长度避免越界</span>
    <span class="token keyword">if</span> limit <span class="token operator">&gt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">:</span>
        limit <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token builtin">sum</span><span class="token punctuation">(</span>l<span class="token punctuation">[</span><span class="token punctuation">:</span>limit<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为做切片不会抛出任何错误，所以不需要判断<code>limit</code>是否超出范围，直接做<code>sum</code>操作即可：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">sum_list</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> limit<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> <span class="token builtin">sum</span><span class="token punctuation">(</span>l<span class="token punctuation">[</span><span class="token punctuation">:</span>limit<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>利用这个特点，我们还可以简化一些特定的边界处理逻辑。比如安全删除列表的某个元素：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code>
<span class="token comment"># 使用异常捕获安全删除列表的第 5 个元素</span>
<span class="token keyword">try</span><span class="token punctuation">:</span>
    l<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
<span class="token keyword">except</span> IndexError<span class="token punctuation">:</span>
    <span class="token keyword">pass</span>

<span class="token comment"># 删除从 5 开始的长度为 1 的切片，不需要捕获任何异常</span>
<span class="token keyword">del</span> l<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token number">6</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="好用又危险的-or-操作符" tabindex="-1"><a class="header-anchor" href="#好用又危险的-or-操作符" aria-hidden="true">#</a> 好用又危险的 “or” 操作符</h2><p><code>or</code>是一个几乎在所有编程语言里都有的操作符，它在Python里通常被用来和<code>and</code>一起做布尔值逻辑运算。比如:</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token boolean">False</span> <span class="token keyword">or</span> <span class="token boolean">True</span>
<span class="token boolean">True</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>但<code>or</code>还有一个有趣的特点是短路求值，比如在下面的例子里，<code>1 / 0</code>永远不会被执行（也就意味着不会抛出<code>ZeroDivisionError</code>）：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token boolean">True</span> <span class="token keyword">or</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">/</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>在很多场景下，我们可以利用<code>or</code>的特点来简化一些边界处理逻辑。看看下面这个例子：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code>
context <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token comment"># 仅当 extra_context 不为 None 时，将其追加进 context 中</span>
<span class="token keyword">if</span> extra_context<span class="token punctuation">:</span>
    context<span class="token punctuation">.</span>update<span class="token punctuation">(</span>extra_context<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这段代码里，<code>extra_context</code>的值一般情况下会是一个字典，但有时也可能是<code>None</code>。所以我加了一个条件判断语句，当它的值不为<code>None</code>时才做<code>.update</code>操作。</p><p>如果使用<code>or</code>操作符，我们可以让上面的语句更简练：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code>context<span class="token punctuation">.</span>update<span class="token punctuation">(</span>extra_context <span class="token keyword">or</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>因为<code>a or b or c or ...</code>这样的表达式，会返回这些变量里第一个布尔值为真的值，直到最后一个为止。所以<code>None or {}</code>其实就等于<code>{}</code>，于是当<code>extra_context</code>值为<code>None</code>时，我们的<code>or</code>表达式会将它变成一个空字典。之前的条件判断就可以被简化成一个<code>or</code>表达式了。</p><p>使用<code>a or b</code>来表示<code>a 为空时用 b 代替</code>，这种写法一点也不新鲜。你在各种编程语、各类框架源码源码里都能发现它的影子。但在这个写法下，其实也藏有一个<code>陷阱</code>。</p><p>因为<code>or</code>操作计算的是变量的布尔真假值。所以，不光是 None，所有的<code>0、[]、{}、set()</code>以及其他所有会被判断为布尔假的东西，都会在<code>or</code>运算中被忽略。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token comment"># 所有的 0、空列表、空字符串等，都是布尔假值</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token builtin">bool</span><span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">bool</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">bool</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">bool</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">bool</span><span class="token punctuation">(</span><span class="token string">&#39;&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">bool</span><span class="token punctuation">(</span><span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token boolean">False</span><span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果忘记了<code>or</code>的这个特点，可能会碰到一些很奇怪的问题。比如这段代码：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code>timeout <span class="token operator">=</span> config<span class="token punctuation">.</span>timeout <span class="token keyword">or</span> <span class="token number">60</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>虽然上面代码的目的，是想要判断当<code>config.timeout</code>为None时使用<code>60</code>做默认值。但假如<code>config.timeout</code>的值被主动配置成了<code>0</code>秒，<code>timeout</code>也会因为上面的<code>0 or 60</code>运算被重新赋值为<code>60</code>。</p><blockquote><p>正确的配置因此被忽略掉了。</p></blockquote><p>所以，有时使用<code>if</code>来进行精确的边界处理会更稳妥一些：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">if</span> config<span class="token punctuation">.</span>timeout <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
    timeout <span class="token operator">=</span> <span class="token number">60</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="不要手动去做数据校验" tabindex="-1"><a class="header-anchor" href="#不要手动去做数据校验" aria-hidden="true">#</a> 不要手动去做数据校验</h2><p>无数前辈的经验告诉我们：<code>不要信任任何用户输入</code>。这意味着所有存在用户输入的地方，都必须对其进行校验。</p><blockquote><p>那些无效、危险的用户输入值，就是需要我们处理的边界情况。</p></blockquote><p>假如我在写一个命令行小程序，需要让用户输入一个<code>0-100</code>范围的数字。要是用户的输入无效，就要求其重新输入。</p><p>程序大概长这样：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">input_a_number</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">&quot;&quot;&quot;
    要求用户输入一个 0-100 的数字，如果无效则重新输入
    &quot;&quot;&quot;</span>
    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
        number <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">&#39;Please input a number (0-100): &#39;</span><span class="token punctuation">)</span>

        <span class="token comment">#  此处往下的三条 if 语句都是输入值的边界校验代码</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> number<span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&#39;Input can not be empty!&#39;</span><span class="token punctuation">)</span>
            <span class="token keyword">continue</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> number<span class="token punctuation">.</span>isdigit<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&#39;Your input is not a valid number!&#39;</span><span class="token punctuation">)</span>
            <span class="token keyword">continue</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">&lt;=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&#39;Please input a number between 0 and 100!&#39;</span><span class="token punctuation">)</span>
            <span class="token keyword">continue</span>

        number <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span>
        <span class="token keyword">break</span>

    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f&#39;Your number is </span><span class="token interpolation"><span class="token punctuation">{</span>number<span class="token punctuation">}</span></span><span class="token string">&#39;</span></span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行效果如下：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code>Please <span class="token builtin">input</span> a number <span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">-</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
Input can <span class="token keyword">not</span> be empty!
Please <span class="token builtin">input</span> a number <span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">-</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">:</span> foo
Your <span class="token builtin">input</span> <span class="token keyword">is</span> <span class="token keyword">not</span> a valid number!
Please <span class="token builtin">input</span> a number <span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">-</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token number">65</span>
Your number <span class="token keyword">is</span> <span class="token number">65</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个函数一共有 14 行有效代码。其中有 3 段 if 共 9 行代码，都是用于校验的边界值检查代码。也许你觉得这样的检查很正常，但请想象一下，假如需要校验的输入不止一个、校验逻辑也比这个复杂怎么办？那样的话，<code>这些边界值检查代码就会变得又臭又长</code>。</p><p>如何改进这些代码呢？把它们抽离出去，作为一个校验函数和核心逻辑隔离开是个不错的办法。但更重要的在于，要把“输入数据校验”作为一个独立的职责与领域，用更恰当的模块来完成这项工作。</p><p>在数据校验这块，<code>pydantic</code>[5] 模块是一个不错的选择。如果用它来做校验，代码可以被简化成这样:</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">from</span> pydantic <span class="token keyword">import</span> BaseModel<span class="token punctuation">,</span> conint<span class="token punctuation">,</span> ValidationError


<span class="token keyword">class</span> <span class="token class-name">NumberInput</span><span class="token punctuation">(</span>BaseModel<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 使用类型注解 conint 定义 number 属性的取值范围</span>
    number<span class="token punctuation">:</span> conint<span class="token punctuation">(</span>ge<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> le<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">)</span>


<span class="token keyword">def</span> <span class="token function">input_a_number_with_pydantic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
        number <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">&#39;Please input a number (0-100): &#39;</span><span class="token punctuation">)</span>

        <span class="token comment"># 实例化为 pydantic 模型，捕获校验错误异常</span>
        <span class="token keyword">try</span><span class="token punctuation">:</span>
            number_input <span class="token operator">=</span> NumberInput<span class="token punctuation">(</span>number<span class="token operator">=</span>number<span class="token punctuation">)</span>
        <span class="token keyword">except</span> ValidationError <span class="token keyword">as</span> e<span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
            <span class="token keyword">continue</span>

        number <span class="token operator">=</span> number_input<span class="token punctuation">.</span>number
        <span class="token keyword">break</span>

    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f&#39;Your number is </span><span class="token interpolation"><span class="token punctuation">{</span>number<span class="token punctuation">}</span></span><span class="token string">&#39;</span></span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>在日常编码时，我们应该尽量避免去手动校验数据。而是应该使用（或者自己实现）合适的第三方校验模块，把这部分边界处理工作抽象出去，<code>简化主流程代码</code>。</p></blockquote><blockquote><p>Hint: 假如你在开发 Web 应用，那么数据校验部分通常来说都挺容易。比如<code>Django</code>框架有自己的<code>forms</code>模块，<code>Flask</code>也可以使用<code>WTForms</code>来进行数据校验。</p></blockquote><h2 id="不要忘记做数学计算" tabindex="-1"><a class="header-anchor" href="#不要忘记做数学计算" aria-hidden="true">#</a> 不要忘记做数学计算</h2><p>很多年前刚接触 Web 开发时，我想学着用 JavaScript 来实现一个简单的文字跑马灯动画。如果你不知道啥是“跑马灯”，我可以稍微解释一下。“跑马灯”就是让一段文字从页面左边往右边不断循环滚动，十几年前的网站特别流行这个。😬</p><p>我记得里面有一段逻辑是这样的：控制文字不断往右边移动，当横坐标超过页面宽度时，重置坐标后继续。我当时写出来的代码，翻译成<code>Python</code>大概是这样：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> element<span class="token punctuation">.</span>position_x <span class="token operator">&gt;</span> page_width<span class="token punctuation">:</span>
        <span class="token comment"># 边界情况：当对象位置超过页面宽度时，重置位置到最左边</span>
        element<span class="token punctuation">.</span>position_x <span class="token operator">-=</span> page_width

    <span class="token comment"># 元素向右边滚动一个单位宽度</span>
    element<span class="token punctuation">.</span>position_x <span class="token operator">+=</span> width_unit
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>看上去还不错对不对？我刚写完它时也是这么认为的。但后来有一天，我重新看到它时，才发现其中的古怪之处。</p><p>在上面的代码里，我需要在主循环里保证<code>element.position_x</code>不会超过页面宽度<code>page_width</code>。所以我写了一个<code>if</code>来处理当<code>position_x</code>超过页面宽度的情况。</p><p>但如果是要保证某个累加的数字（position_x）不超过另一个数字（page_width），直接用<code>%</code>做取模运算不就好了吗？</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
    <span class="token comment"># 使用 % page_with 控制不要超过页面宽度</span>
    element<span class="token punctuation">.</span>position_x <span class="token operator">=</span> <span class="token punctuation">(</span>element<span class="token punctuation">.</span>position_x <span class="token operator">+</span> width_unit<span class="token punctuation">)</span> <span class="token operator">%</span> page_with
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样写的话，代码里的边界情况就连着那行<code>if</code>语句一起消失了。</p><p>和取模运算类似的操作还有很多，比如<code>abs()、math.floor()</code>等等。</p><p>我们应该记住，不要写出<code>if value &lt; 0: value = -value</code>这种边界判断代码，直接使用<code>abs(value)</code>就好，不要重新发明绝对值运算。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p><code>边界情况（Edge cases）</code>是我们在日常编码时的老朋友，但它不怎么招人喜欢。</p><p>毕竟，我们都希望自己的代码只有一条主流程贯穿始终，不需要太多的条件判断、异常捕获。</p><p>但边界情况同时又是无法避免的，只要有代码，边界情况就会存在。所以，如果能更好的处理它们，我们的代码就可以变得更清晰易读。</p><p>除了上面介绍的这些思路外，还有很多东西都可以帮助我们处理边界情况，比如利用面向对象的<code>多态特性</code>、使用<code>空对象模式</code>[6] 等等。</p><p>最后再总结一下：</p><ul><li>使用条件判断和异常捕获都可以用来处理边界情况。</li><li>在 Python 里，我们更倾向于使用基于异常捕获的 EAFP 风格。</li><li>使用<code>defaultdict / setdefault / pop</code>可以巧妙的处理当键不存在时的边界情况。</li><li>对列表进行不存在的范围切片不会抛出异常。</li><li>使用<code>or</code>可以简化默认值边界处理逻辑，但也要注意不要掉入陷阱。</li><li>不要手动去做数据校验，使用<code>pydantic</code>或其他的数据校验模块。</li><li>利用取模、绝对值计算等方式，可以简化一些特定的边界处理逻辑。</li></ul><h2 id="references" tabindex="-1"><a class="header-anchor" href="#references" aria-hidden="true">#</a> References</h2>`,132),d={href:"https://www.ted.com/talks/linus_torvalds_the_mind_behind_linux/transcript?language=en",target:"_blank",rel:"noopener noreferrer"},r=s("br",null,null,-1),k={href:"https://en.wikipedia.org/wiki/Edge_case",target:"_blank",rel:"noopener noreferrer"},v=s("br",null,null,-1),m={href:"https://jeffknupp.com/blog/2013/02/06/write-cleaner-python-use-exceptions/",target:"_blank",rel:"noopener noreferrer"},b=s("br",null,null,-1),h={href:"https://docs.python.org/3/library/collections.html#collections.Counter",target:"_blank",rel:"noopener noreferrer"},y=s("br",null,null,-1),g={href:"https://pydantic-docs.helpmanual.io/",target:"_blank",rel:"noopener noreferrer"},f=s("br",null,null,-1),_={href:"https://github.com/piglei/one-python-craftsman/blob/master/zh_CN/5-function-returning-tips.md#5-%E5%90%88%E7%90%86%E4%BD%BF%E7%94%A8%E7%A9%BA%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F",target:"_blank",rel:"noopener noreferrer"},w=s("br",null,null,-1),x={href:"https://github.com/piglei/one-python-craftsman",target:"_blank",rel:"noopener noreferrer"},q=s("br",null,null,-1),E={href:"https://github.com/piglei/one-python-craftsman",target:"_blank",rel:"noopener noreferrer"};function P(F,L){const a=p("ExternalLinkIcon");return o(),c("div",null,[u,s("p",null,[n("[1] TED 访谈节目: "),s("a",d,[n("https://www.ted.com/talks/linus_torvalds_the_mind_behind_linux/transcript?language=en"),e(a)]),r,n(" [2] 边界情况（Edge Case）: "),s("a",k,[n("https://en.wikipedia.org/wiki/Edge_case"),e(a)]),v,n(" [3] Write Cleaner Python: Use Exceptions: "),s("a",m,[n("https://jeffknupp.com/blog/2013/02/06/write-cleaner-python-use-exceptions/"),e(a)]),b,n(" [4] collections.Counter: "),s("a",h,[n("https://docs.python.org/3/library/collections.html#collections.Counter"),e(a)]),y,n(" [5] pydantic: "),s("a",g,[n("https://pydantic-docs.helpmanual.io/"),e(a)]),f,n(" [6] 空对象模式: "),s("a",_,[n("https://github.com/piglei/one-python-craftsman/blob/master/zh_CN/5-function-returning-tips.md#5-合理使用空对象模式"),e(a)]),w,n(" [7] 项目 Github Issues: "),s("a",x,[n("https://github.com/piglei/one-python-craftsman"),e(a)]),q,n(" [8] 所有文章索引 [Github]: "),s("a",E,[n("https://github.com/piglei/one-python-craftsman"),e(a)])])])}const B=t(i,[["render",P],["__file","Python 工匠：在边界处思考.html.vue"]]);export{B as default};
