import{_ as r}from"./海哥python-6b198e2b.js";import{_ as o}from"./plugin-vue_export-helper-c27b6911.js";import{r as t,o as i,c as l,a as n,b as a,e,f as p}from"./app-967d79b2.js";const c="/assets/错误优化思路-ecdb4f0e.png",d={},u=p(`<blockquote><p>要写出⾼质量的Go代码，我们需要始终想着错误处理。</p></blockquote><h2 id="了解错误处理的策略" tabindex="-1"><a class="header-anchor" href="#了解错误处理的策略" aria-hidden="true">#</a> 了解错误处理的策略</h2><blockquote><p>错误是值，只是以error接⼝变量的形式统⼀呈现。</p></blockquote><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">var</span> err <span class="token builtin">error</span>
err <span class="token operator">=</span> errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">&quot;this is a demo error&quot;</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>error接⼝是Go原⽣内置的类型，它的定义如下：</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">type</span> <span class="token keyword">interface</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>
 <span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>任何实现了<code>Error() string</code>⽅法的类型的实例均可作为错误赋值给<code>error</code>接⼝变量。</p><p>在⼀些场景下，错误处理者需要从错误值中提取出更多信息以帮助其选择错误处理路径，这时他们可以⾃定义错误类型来满⾜需求。⽐如：标准库中的net包就定义了⼀种携带额外错误上下⽂的错误类型。</p><p>error接⼝是错误值提供者与错误值检视者之间的契约。error接⼝的实现者负责提供错误上下⽂供负责错误处理的代码使⽤。这种错误上下⽂与error接⼝类型的分离体现了Go设计哲学中的“正交”理念。</p><h3 id="透明错误处理策略" tabindex="-1"><a class="header-anchor" href="#透明错误处理策略" aria-hidden="true">#</a> 透明错误处理策略</h3><p>Go语⾔中的错误处理就是根据函数/⽅法返回的error类型变量中携带的错误值信息做决策并选择后续代码执⾏路径的过程。最简单的错误策略莫过于完全不关⼼返回错误值携带的具体上下⽂信息，只要发<br> ⽣错误就进⼊唯⼀的错误处理执⾏路径。</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code>err <span class="token operator">:=</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
 <span class="token comment">// 不关⼼err变量底层错误值所携带的具体上下⽂信息</span>
 <span class="token comment">// 执⾏简单错误处理逻辑并返回</span>
 <span class="token operator">...</span>
 <span class="token keyword">return</span> err
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这种策略下由于错误处理⽅并不关⼼错误值的上下⽂，因此错误值的构造⽅（如上⾯的函数doSomething）可以直接使⽤Go标准库提供的两个基本错误值构造⽅法errors.New和fmt.Errorf构造错误值。</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>
 <span class="token operator">...</span>
 <span class="token keyword">return</span> errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">&quot;some error occurred&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="哨兵-错误处理策略" tabindex="-1"><a class="header-anchor" href="#哨兵-错误处理策略" aria-hidden="true">#</a> “哨兵”错误处理策略</h3><blockquote><p>透明错误处理策略时，若根据值进行后续处理，本身值可能被改动，并且字符串比较的方式对错误值进⾏检视的性能也很差。</p></blockquote><p>从Go 1.13版本开始，标准库errors包提供了Is⽅法⽤于错误处理⽅对错误值进⾏检视。</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token comment">// 类似 if err == ErrOutOfBounds{ … }</span>
<span class="token keyword">if</span> errors<span class="token punctuation">.</span><span class="token function">Is</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> ErrOutOfBounds<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token comment">// 越界的错误处理</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果error类型变量的底层错误值是⼀个包装错误（wrap error），errors.Is⽅法会沿着该包装错误所在错误链（error chain）与链上所有被包装的错误（wrapped error）进⾏⽐较，直⾄找到⼀个匹配的错误。</p><h3 id="错误值类型检视策略" tabindex="-1"><a class="header-anchor" href="#错误值类型检视策略" aria-hidden="true">#</a> 错误值类型检视策略</h3><p>从Go 1.13版本开始，标准库errors包提供了As⽅法⽤于错误处理⽅对错误值进⾏检视。As⽅法类似于通过类型断⾔判断⼀个error类型变量是否为特定的⾃定义错误类型：</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token comment">// 类似 if e, ok := err.(*MyError); ok { … }</span>
<span class="token keyword">var</span> e <span class="token operator">*</span>MyError
<span class="token keyword">if</span> errors<span class="token punctuation">.</span><span class="token function">As</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> <span class="token operator">&amp;</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token comment">// 如果err类型为*MyError，变量e将被设置为对应的错误值</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不同的是，如果error类型变量的底层错误值是⼀个包装错误，那么errors.As⽅法会沿着该包装错误所在错误链与链上所有被包装的错误的类型进⾏⽐较，直⾄找到⼀个匹配的错误类型。</p><blockquote><p>如果你使⽤的是Go 1.13及后续版本，请尽量使⽤errors.As⽅法去检视某个错误值是不是某个⾃定义错误类型的实例。</p></blockquote><h3 id="错误行为特征检视策略" tabindex="-1"><a class="header-anchor" href="#错误行为特征检视策略" aria-hidden="true">#</a> 错误⾏为特征检视策略</h3><h3 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h3><ul><li>尽量使⽤透明错误处理策略降低错误处理⽅与错误值构造⽅之间的耦合；</li><li>如果可以通过错误值类型的特征进⾏错误检视，那么尽量使⽤错误⾏为特征检视策略；</li><li>在上述两种策略⽆法实施的情况下，再⽤“哨兵”策略和错误值类型检视策略；</li><li>在Go 1.13及后续版本中，尽量⽤errors.Is和errors.As⽅法替换原先的错误检视⽐较语句</li></ul><h2 id="尽量优化反复出现的if-err-nil" tabindex="-1"><a class="header-anchor" href="#尽量优化反复出现的if-err-nil" aria-hidden="true">#</a> 尽量优化反复出现的if err != nil</h2><p>优化反复出现的<code>if err != nil</code>代码块的根本⽬的是让错误检查和处理较少，不要⼲扰正常业务代码，让正常业务代码更具视觉连续性。</p><figure><img src="`+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="不要使用panic进行正常的错误处理" tabindex="-1"><a class="header-anchor" href="#不要使用panic进行正常的错误处理" aria-hidden="true">#</a> 不要使⽤panic进⾏正常的错误处理</h2><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考" aria-hidden="true">#</a> 参考</h2>',32),k=n("br",null,null,-1),h={href:"https://github.com/golang/proposal/blob/master/design/go2draft-error-handling-overview.md",target:"_blank",rel:"noopener noreferrer"},v=n("br",null,null,-1),g={href:"https://go.dev/blog/errors-are-values",target:"_blank",rel:"noopener noreferrer"},m=n("br",null,null,-1),b={href:"https://blog.golang.org/defer-panic-and-recover",target:"_blank",rel:"noopener noreferrer"},f=n("hr",null,null,-1),_=n("figure",null,[n("img",{src:r,alt:"",tabindex:"0",loading:"lazy"}),n("figcaption")],-1);function x(w,y){const s=t("ExternalLinkIcon");return i(),l("div",null,[u,n("blockquote",null,[n("p",null,[a("tonybai"),k,n("a",h,[a("https://github.com/golang/proposal/blob/master/design/go2draft-error-handling-overview.md"),e(s)]),v,n("a",g,[a("https://go.dev/blog/errors-are-values"),e(s)]),m,n("a",b,[a("https://blog.golang.org/defer-panic-and-recover"),e(s)])])]),f,_])}const N=o(d,[["render",x],["__file","30.错误处理.html.vue"]]);export{N as default};
