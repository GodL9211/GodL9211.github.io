import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{r,o as d,c,a as e,b as t,e as o,f as s}from"./app-7702e136.js";const i={},p=s('<h1 id="rest-framework专栏讲解-五-request" tabindex="-1"><a class="header-anchor" href="#rest-framework专栏讲解-五-request" aria-hidden="true">#</a> Rest-framework专栏讲解(五)：Request</h1><h2 id="目录" tabindex="-1"><a class="header-anchor" href="#目录" aria-hidden="true">#</a> 目录</h2><ul><li><a href="#%E7%82%B9%E5%87%BB%E8%B7%B3%E8%BD%AC%E5%88%B0-Rest-Framework-%E4%B8%93%E6%A0%8F%E7%9B%AE%E5%BD%95">点击跳转到 Rest-Framework 专栏目录</a></li><li><a href="#Request-%E8%A7%A3%E6%9E%90">Request 解析</a><ul><li><a href="#data">.data</a></li><li><a href="#query_params">.query_params</a></li><li><a href="#parsers">.parsers</a></li></ul></li><li><a href="#%E5%86%85%E5%AE%B9%E5%8D%8F%E5%95%86">内容协商</a><ul><li><a href="#accepted_renderer">.accepted_renderer</a></li><li><a href="#accepted_media_type">.accepted_media_type</a></li></ul></li><li><a href="#%E8%AE%A4%E8%AF%81Authentication">认证（Authentication）</a><ul><li><a href="#user">.user</a></li><li><a href="#auth">.auth</a></li><li><a href="#authenticators">.authenticators</a></li></ul></li><li><a href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A2%9E%E5%BC%BA">浏览器增强</a><ul><li><a href="#method">.method</a></li><li><a href="#content_type">.content_type</a></li><li><a href="#stream">.stream</a></li></ul></li><li><a href="#%E6%A0%87%E5%87%86%E7%9A%84-HttpRequest-%E5%B1%9E%E6%80%A7">标准的 HttpRequest 属性</a></li></ul><hr>',4),l={id:"点击跳转到-rest-framework-专栏目录",tabindex:"-1"},u=e("a",{class:"header-anchor",href:"#点击跳转到-rest-framework-专栏目录","aria-hidden":"true"},"#",-1),h={href:"https://juejin.cn/post/6844904185163415566",title:"点击跳转到 Rest-Framework 专栏目录",target:"_blank",rel:"noopener noreferrer"},_={href:"http://www.django-rest-framework.org/api-guide/requests/",title:"官方原文链接",target:"_blank",rel:"noopener noreferrer"},f=e("p",null,[t("框架的 "),e("code",null,"request"),t(" 给予了很标准的属性, 并拓展了标准 "),e("code",null,"HTTPRequest"),t(" 对象, 比如更加灵活的请求解析"),e("code",null,"（request parsing）"),t("和认证"),e("code",null,"（request authentication）"),t("，你会在开发中很方便的使用它。")],-1),m=e("blockquote",null,[e("p",null,[t("🐍如果你正在开发基于 REST 的 web API 服务...... 应该忽略 request.POST。 — "),e("em",null,"Malcom Tredinnick，Django 开发组")])],-1),k={id:"request-解析",tabindex:"-1"},b=e("a",{class:"header-anchor",href:"#request-解析","aria-hidden":"true"},"#",-1),E={href:"http://drf.jiuyou.info/#/drf/requests?id=request-%E8%A7%A3%E6%9E%90",title:"Request 解析",target:"_blank",rel:"noopener noreferrer"},q=s(`<p>REST framwork 的 <code>Request</code> 对象提供了灵活的请求解析，允许你使用 <code>JSON data </code>或 <code>其他 media types </code>像通常处理表单数据一样处理请求。</p><h3 id="data" tabindex="-1"><a class="header-anchor" href="#data" aria-hidden="true">#</a> .data</h3><p>在 <code>request.data</code> 中你可以很方便的获取客户端传递给你的 json 数据或者表单提交, 不需要像 <code>request.POST.get()</code> 一样很麻烦的操作, 并且能解析文件传输，这跟标准的 <code>request.POST</code> 和 <code>request.FILES</code> 类似，并且还具有以下特点：</p><ul><li>包括所有解析的内容，文件（file） 和 非文件（non-file inputs）。</li><li>支持解析 <code>POST</code> 以外的 HTTP method ， 比如 <code>PUT</code>， <code>PATCH</code>。</li><li>更加灵活，不仅仅支持表单数据，传入同样的 JSON 数据一样可以正确解析，并且不用做额外的处理（意思是前端不管提交的是表单数据，还是 JSON 数据，<code>.data</code> 都能够正确解析）。</li></ul><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">update</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> request<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> request<span class="token punctuation">.</span>data<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">&#39;params&#39;</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="query-params" tabindex="-1"><a class="header-anchor" href="#query-params" aria-hidden="true">#</a> .query_params</h3><p>在 <code>GET</code> 请求中, <code>query_params</code> 的命名方式才更加凸显传参的方式, 当然, <code>request.query_params.get(&#39;params&#39;)</code> 和 <code>request.GET.get(&#39;params&#39;)</code> 是等价的。</p><p><code>为了代码更加清晰可读</code>，推荐使用 <code>request.query_params</code> ，而不是 Django 中的 <code>request.GET</code>，这样那够让你的代码更加明显的体现出 ----- 任何 HTTP method 类型都可能包含查询参数（query parameters），而不仅仅只是 &#39;GET&#39; 请求。</p>`,8),g={id:"parsers",tabindex:"-1"},T=e("a",{class:"header-anchor",href:"#parsers","aria-hidden":"true"},"#",-1),y={href:"http://wiznote-desktop/ks/note/view/79a579df-0e97-4971-8f60-86ed3beffd85/88812cbe-312e-4398-be81-6b799c703363/index.html?lang=zh-cn&readerType=common&isPersonalKb=1&canEdit=1&userGuid=79a579df-0e97-4971-8f60-86ed3beffd85&alias=godl9211&pSpacing=16&darkBgColor=transparent&darkTextColor=#f0f0f0&isFromWizClipper=1&xssNoFrame=1&themeMode=auto&resourcesPath=&frameKey=normal_note_88812cbe-312e-4398-be81-6b799c703363#/drf/requests?id=parsers",title:".parsers",target:"_blank",rel:"noopener noreferrer"},A=s(`<p><code>APIView</code> 类或者 <code>@api_view</code> 装饰器将根据视图上设置的 <code>parser_classes</code> 或 <code>settings</code> 文件中的 <code>DEFAULT_PARSER_CLASSES</code> 设置来确保此属性（<code>.parsers</code>）自动设置为 <code>Parser</code> 实例列表。</p><p><strong>通常不需要关注该属性......</strong></p><p>如果你非要看看它里面是什么，可以打印出来看看，大概长这样：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token punctuation">[</span><span class="token operator">&lt;</span>rest_framework<span class="token punctuation">.</span>parsers<span class="token punctuation">.</span>JSONParser <span class="token builtin">object</span> at <span class="token number">0x7fa850202d68</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>rest_framework<span class="token punctuation">.</span>parsers<span class="token punctuation">.</span>FormParser <span class="token builtin">object</span> at <span class="token number">0x7fa850202be0</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>rest_framework<span class="token punctuation">.</span>parsers<span class="token punctuation">.</span>MultiPartParser <span class="token builtin">object</span> at <span class="token number">0x7fa850202860</span><span class="token operator">&gt;</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>恩，包含三个解析器 <code>JSONParser</code>，<code>FormParser</code>，<code>MultiPartParser</code>。</p><blockquote><p>注意： 如果客户端发送格式错误的内容，则访问 <code>request.data</code> 可能会引发 <code>ParseError</code> 。默认情况下， REST framework 的 <code>APIView</code> 类或者 <code>@api_view</code> 装饰器将捕获错误并返回 <code>400 Bad Request</code> 响应。 如果客户端发送的请求内容无法解析（不同于格式错误），则会引发 <code>UnsupportedMediaType</code> 异常，默认情况下会被捕获并返回 <code>415 Unsupported Media Type</code> 响应。</p></blockquote>`,6),x={id:"内容协商",tabindex:"-1"},w=e("a",{class:"header-anchor",href:"#内容协商","aria-hidden":"true"},"#",-1),P={href:"http://wiznote-desktop/ks/note/view/79a579df-0e97-4971-8f60-86ed3beffd85/88812cbe-312e-4398-be81-6b799c703363/index.html?lang=zh-cn&readerType=common&isPersonalKb=1&canEdit=1&userGuid=79a579df-0e97-4971-8f60-86ed3beffd85&alias=godl9211&pSpacing=16&darkBgColor=transparent&darkTextColor=#f0f0f0&isFromWizClipper=1&xssNoFrame=1&themeMode=auto&resourcesPath=&frameKey=normal_note_88812cbe-312e-4398-be81-6b799c703363#/drf/requests?id=%E5%86%85%E5%AE%B9%E5%8D%8F%E5%95%86",title:"内容协商",target:"_blank",rel:"noopener noreferrer"},R=e("p",null,"该请求公开了一些属性，允许你确定内容协商阶段的结果。这使你可以实施一些行为，例如为不同媒体类型选择不同的序列化方案。",-1),v={id:"accepted-renderer",tabindex:"-1"},B=e("a",{class:"header-anchor",href:"#accepted-renderer","aria-hidden":"true"},"#",-1),S={href:"http://wiznote-desktop/ks/note/view/79a579df-0e97-4971-8f60-86ed3beffd85/88812cbe-312e-4398-be81-6b799c703363/index.html?lang=zh-cn&readerType=common&isPersonalKb=1&canEdit=1&userGuid=79a579df-0e97-4971-8f60-86ed3beffd85&alias=godl9211&pSpacing=16&darkBgColor=transparent&darkTextColor=#f0f0f0&isFromWizClipper=1&xssNoFrame=1&themeMode=auto&resourcesPath=&frameKey=normal_note_88812cbe-312e-4398-be81-6b799c703363#/drf/requests?id=accepted_renderer",title:".accepted_renderer",target:"_blank",rel:"noopener noreferrer"},F=e("p",null,"渲染器实例是由内容协商阶段选择的。",-1),C={id:"accepted-media-type",tabindex:"-1"},j=e("a",{class:"header-anchor",href:"#accepted-media-type","aria-hidden":"true"},"#",-1),N={href:"http://wiznote-desktop/ks/note/view/79a579df-0e97-4971-8f60-86ed3beffd85/88812cbe-312e-4398-be81-6b799c703363/index.html?lang=zh-cn&readerType=common&isPersonalKb=1&canEdit=1&userGuid=79a579df-0e97-4971-8f60-86ed3beffd85&alias=godl9211&pSpacing=16&darkBgColor=transparent&darkTextColor=#f0f0f0&isFromWizClipper=1&xssNoFrame=1&themeMode=auto&resourcesPath=&frameKey=normal_note_88812cbe-312e-4398-be81-6b799c703363#/drf/requests?id=accepted_media_type",title:".accepted_media_type",target:"_blank",rel:"noopener noreferrer"},z=e("p",null,"表示内容协商阶段接受的 media type 的字符串。",-1),H={id:"认证-authentication",tabindex:"-1"},M=e("a",{class:"header-anchor",href:"#认证-authentication","aria-hidden":"true"},"#",-1),D={href:"http://drf.jiuyou.info/#/drf/requests?id=%E8%AE%A4%E8%AF%81%EF%BC%88authentication%EF%BC%89",title:"认证（Authentication）",target:"_blank",rel:"noopener noreferrer"},G=s('<p>REST framework 提供了灵活的认证方式：</p><ul><li>可以在 API 的不同部分使用不同的认证策略。</li><li>支持同时使用多个身份验证策略。</li><li>提供与传入请求关联的用户（user）和令牌（token）信息。</li></ul><h3 id="user" tabindex="-1"><a class="header-anchor" href="#user" aria-hidden="true">#</a> .user</h3><p><code>request.user</code> 通常会返回 <code>django.contrib.auth.models.User</code> 的一个实例，但其行为取决于正在使用的身份验证策略。</p><p>在你已认证的情况下, 访问该属性得到的是你用户模型的一个实例对象, 你可以通过 <code>request.user.id</code> 的方式获取用户 ID 属性, 但在未验证, 或者未通过验证的情况下该属性返回的是 <code>django.contrib.auth.models.AnonymousUser</code> 的一个实例对象。</p><h3 id="auth" tabindex="-1"><a class="header-anchor" href="#auth" aria-hidden="true">#</a> .auth</h3><p><code>request.auth</code> 返回任何附加的认证上下文（authentication context）。<code>request.auth</code> 的确切行为取决于正在使用的身份验证策略，但它通常可能是请求经过身份验证的令牌（token）实例。</p><p>如果请求未经身份验证，或者没有附加上下文（context），则 <code>request.auth</code> 的默认值为 <code>None</code>。</p>',8),K={id:"authenticators",tabindex:"-1"},O=e("a",{class:"header-anchor",href:"#authenticators","aria-hidden":"true"},"#",-1),I={href:"http://wiznote-desktop/ks/note/view/79a579df-0e97-4971-8f60-86ed3beffd85/88812cbe-312e-4398-be81-6b799c703363/index.html?lang=zh-cn&readerType=common&isPersonalKb=1&canEdit=1&userGuid=79a579df-0e97-4971-8f60-86ed3beffd85&alias=godl9211&pSpacing=16&darkBgColor=transparent&darkTextColor=#f0f0f0&isFromWizClipper=1&xssNoFrame=1&themeMode=auto&resourcesPath=&frameKey=normal_note_88812cbe-312e-4398-be81-6b799c703363#/drf/requests?id=authenticators",title:".authenticators",target:"_blank",rel:"noopener noreferrer"},U=s(`<p><code>APIView</code> 类或 <code>@api_view</code> 装饰器将确保根据视图上设置的 <code>authentication_classes</code> 或基于 <code>settings</code> 文件中的 <code>DEFAULT_AUTHENTICATORS</code> 设置将此属性（<code>.authenticators</code>）自动设置为 <code>Authentication</code> 实例列表。</p><p>**通常不需要关注该属性...... **</p><blockquote><p>注意：调用 <code>.user</code> 或 <code>.auth</code> 属性时可能会引发 <code>WrappedAttributeError</code> 异常。这些错误源于 authenticator 作为一个标准的 <code>AttributeError</code> ，为了防止它们被外部属性访问修改，有必要重新提升为不同的异常类型。Python 无法识别来自 authenticator 的 <code>AttributeError</code>，并会立即假定请求对象没有 <code>.user</code> 或 <code>.auth</code> 属性。authenticator 需要修复。</p></blockquote><p>多说几句</p><p><code>.authenticators</code> 其实存的就是当前使用的认证器（authenticator）列表，打印出来大概是这样：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token punctuation">[</span><span class="token operator">&lt;</span>rest_framework<span class="token punctuation">.</span>authentication<span class="token punctuation">.</span>SessionAuthentication <span class="token builtin">object</span> at <span class="token number">0x7f8ae4528710</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>rest_framework<span class="token punctuation">.</span>authentication<span class="token punctuation">.</span>BasicAuthentication <span class="token builtin">object</span> at <span class="token number">0x7f8ae45286d8</span><span class="token operator">&gt;</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>可以看到这里使用的认证器（authenticator）包括 <code>SessionAuthentication</code> 和 <code>BasicAuthentication</code>。</p>`,7),L={id:"浏览器增强",tabindex:"-1"},V=e("a",{class:"header-anchor",href:"#浏览器增强","aria-hidden":"true"},"#",-1),W={href:"http://wiznote-desktop/ks/note/view/79a579df-0e97-4971-8f60-86ed3beffd85/88812cbe-312e-4398-be81-6b799c703363/index.html?lang=zh-cn&readerType=common&isPersonalKb=1&canEdit=1&userGuid=79a579df-0e97-4971-8f60-86ed3beffd85&alias=godl9211&pSpacing=16&darkBgColor=transparent&darkTextColor=#f0f0f0&isFromWizClipper=1&xssNoFrame=1&themeMode=auto&resourcesPath=&frameKey=normal_note_88812cbe-312e-4398-be81-6b799c703363#/drf/requests?id=%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A2%9E%E5%BC%BA",title:"浏览器增强",target:"_blank",rel:"noopener noreferrer"},J=s('<p>REST framework 支持基于浏览器的 <code>PUT</code>，<code>PATCH</code>，<code>DELETE</code> 表单。</p><h3 id="method" tabindex="-1"><a class="header-anchor" href="#method" aria-hidden="true">#</a> .method</h3><p>该属性能返回请求方式的大写字符串, 如 <code>GET</code>。</p><p><code>request.method</code> 返回请求 HTTP 方法的大写字符串表示形式。如 <code>GET</code>,<code>POST</code>...。</p><p>透明地支持基于浏览器的 <code>PUT</code>，<code>PATCH</code> 和 <code>DELETE</code> 表单。</p><p>在请求中, 如果不需要重写框架的方法, 或者实现自定义返回数据、校验等, 这些属性一般是不会被使用到的。</p>',6),Y={id:"content-type",tabindex:"-1"},Q=e("a",{class:"header-anchor",href:"#content-type","aria-hidden":"true"},"#",-1),X={href:"http://drf.jiuyou.info/#/drf/requests?id=content_type",title:".content_type",target:"_blank",rel:"noopener noreferrer"},Z=s("<p><code>request.content_type</code> 返回表示 HTTP 请求正文的媒体类型（media type）的字符串对象（比如： <code>text/plain</code> , <code>text/html</code> 等），如果没有提供媒体类型，则返回空字符串。</p><p>通常不需要直接访问此属性，一般都依赖与 REST 框架的默认请求解析行为。</p><p>不建议使用 <code>request.META.get(&#39;HTTP_CONTENT_TYPE&#39;)</code> 来获取 content type 。</p><p><em>更多相关信息以后再说～</em></p>",4),$={id:"stream",tabindex:"-1"},ee=e("a",{class:"header-anchor",href:"#stream","aria-hidden":"true"},"#",-1),te={href:"http://drf.jiuyou.info/#/drf/requests?id=stream",title:".stream",target:"_blank",rel:"noopener noreferrer"},ae=e("p",null,[e("code",null,"request.stream"),t(" 返回一个代表请求主体内容的流。")],-1),oe=e("p",null,"通常不需要直接访问此属性，一般都依赖与 REST 框架的默认请求解析行为。",-1),se={id:"标准的-httprequest-属性",tabindex:"-1"},ne=e("a",{class:"header-anchor",href:"#标准的-httprequest-属性","aria-hidden":"true"},"#",-1),re={href:"http://drf.jiuyou.info/#/drf/requests?id=%E6%A0%87%E5%87%86%E7%9A%84-httprequest-%E5%B1%9E%E6%80%A7",title:"标准的 HttpRequest 属性",target:"_blank",rel:"noopener noreferrer"},de=s("<p>由于 REST framework 的 <code>Request</code> 扩展于 Django 的 <code>HttpRequest</code>，所有其他标准属性和方法也可用。例如<code>request.META</code> 和 <code>request.session</code> 字典都可以正常使用。</p><p>请注意，由于实现原因，<code>Request</code> 类不会从 <code>HttpRequest</code> 类继承，而是使用组合扩展类（优先使用组合，而非继承，恩，老铁没毛病 0.0）</p>",2);function ce(ie,pe){const a=r("ExternalLinkIcon");return d(),c("div",null,[p,e("h4",l,[u,t(),e("a",h,[t("点击跳转到 Rest-Framework 专栏目录"),o(a)])]),e("p",null,[e("a",_,[t("官方原文链接"),o(a)])]),f,m,e("h2",k,[b,t(),e("a",E,[t("Request 解析"),o(a)])]),q,e("h3",g,[T,t(),e("a",y,[t(".parsers"),o(a)])]),A,e("h2",x,[w,t(),e("a",P,[t("内容协商"),o(a)])]),R,e("h3",v,[B,t(),e("a",S,[t(".accepted_renderer"),o(a)])]),F,e("h3",C,[j,t(),e("a",N,[t(".accepted_media_type"),o(a)])]),z,e("h2",H,[M,t(),e("a",D,[t("认证（Authentication）"),o(a)])]),G,e("h3",K,[O,t(),e("a",I,[t(".authenticators"),o(a)])]),U,e("h2",L,[V,t(),e("a",W,[t("浏览器增强"),o(a)])]),J,e("h3",Y,[Q,t(),e("a",X,[t(".content_type"),o(a)])]),Z,e("h3",$,[ee,t(),e("a",te,[t(".stream"),o(a)])]),ae,oe,e("h2",se,[ne,t(),e("a",re,[t("标准的 HttpRequest 属性"),o(a)])]),de])}const he=n(i,[["render",ce],["__file","Rest-framework专栏讲解(五)：Request.html.vue"]]);export{he as default};
