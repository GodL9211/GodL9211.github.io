import{_ as d}from"./plugin-vue_export-helper-c27b6911.js";import{r as a,o as l,c as r,a as n,b as e,e as t,f as i}from"./app-9976b6d0.js";const c={},o=i('<h2 id="第47课-mysql-新特性" tabindex="-1"><a class="header-anchor" href="#第47课-mysql-新特性" aria-hidden="true">#</a> 第47课：MySQL 新特性</h2><h4 id="json类型" tabindex="-1"><a class="header-anchor" href="#json类型" aria-hidden="true">#</a> JSON类型</h4><p>很多开发者在使用关系型数据库做数据持久化的时候，常常感到结构化的存储缺乏灵活性，因为必须事先设计好所有的列以及对应的数据类型。在业务发展和变化的过程中，如果需要修改表结构，这绝对是比较麻烦和难受的事情。从 MySQL 5.7 版本开始，MySQL引入了对 JSON 数据类型的支持（MySQL 8.0 解决了 JSON 的日志性能瓶颈问题），用好 JSON 类型，其实就是打破了关系型数据库和非关系型数据库之间的界限，为数据持久化操作带来了更多的便捷。</p><p>JSON 类型主要分为 JSON 对象和 JSON数组两种，如下所示。</p><ol><li>JSON 对象</li></ol><div class="language-JSON line-numbers-mode" data-ext="JSON"><pre class="language-JSON"><code>{&quot;name&quot;: &quot;骆昊&quot;, &quot;tel&quot;: &quot;13122335566&quot;, &quot;QQ&quot;: &quot;957658&quot;}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol start="2"><li>JSON 数组</li></ol><div class="language-JSON line-numbers-mode" data-ext="JSON"><pre class="language-JSON"><code>[1, 2, 3]\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-JSON line-numbers-mode" data-ext="JSON"><pre class="language-JSON"><code>[{&quot;name&quot;: &quot;骆昊&quot;, &quot;tel&quot;: &quot;13122335566&quot;}, {&quot;name&quot;: &quot;王大锤&quot;, &quot;QQ&quot;: &quot;123456&quot;}]\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>哪些地方需要用到JSON类型呢？举一个简单的例子，现在很多产品的用户登录都支持多种方式，例如手机号、微信、QQ、新浪微博等，但是一般情况下我们又不会要求用户提供所有的这些信息，那么用传统的设计方式，就需要设计多个列来对应多种登录方式，可能还需要允许这些列存在空值，这显然不是很好的选择；另一方面，如果产品又增加了一种登录方式，那么就必然要修改之前的表结构，这就更让人痛苦了。但是，有了 JSON 类型，刚才的问题就迎刃而解了，我们可以做出如下所示的设计。</p><div class="language-SQL line-numbers-mode" data-ext="SQL"><pre class="language-SQL"><code>create table `tb_test`\n(\n`user_id` bigint unsigned,\n`login_info` json,\nprimary key (`user_id`)\n) engine=innodb;\n\ninsert into `tb_test` values \n    (1, &#39;{&quot;tel&quot;: &quot;13122335566&quot;, &quot;QQ&quot;: &quot;654321&quot;, &quot;wechat&quot;: &quot;jackfrued&quot;}&#39;),\n    (2, &#39;{&quot;tel&quot;: &quot;13599876543&quot;, &quot;weibo&quot;: &quot;wangdachui123&quot;}&#39;);\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果要查询用户的手机和微信号，可以用如下所示的 SQL 语句。</p><div class="language-SQL line-numbers-mode" data-ext="SQL"><pre class="language-SQL"><code>select \n    `user_id`,\n    json_unquote(json_extract(`login_info`, &#39;$.tel&#39;)) as 手机号,\n    json_unquote(json_extract(`login_info`, &#39;$.wechat&#39;)) as 微信 \nfrom `tb_test`;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>+---------+-------------+-----------+\n| user_id | 手机号      | 微信       |\n+---------+-------------+-----------+\n|       1 | 13122335566 | jackfrued |\n|       2 | 13599876543 | NULL      |\n+---------+-------------+-----------+\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为支持 JSON 类型，MySQL 也提供了配套的处理 JSON 数据的函数，就像上面用到的<code>json_extract</code>和<code>json_unquote</code>。当然，上面的 SQL 还有更为便捷的写法，如下所示。</p><div class="language-SQL line-numbers-mode" data-ext="SQL"><pre class="language-SQL"><code>select \n	`user_id`,\n    `login_info` -&gt;&gt; &#39;$.tel&#39; as 手机号,\n    `login_info` -&gt;&gt; &#39;$.wechat&#39; as 微信\nfrom `tb_test`;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再举个例子，如果我们的产品要实现用户画像功能（给用户打标签），然后基于用户画像给用户推荐平台的服务或消费品之类的东西，我们也可以使用 JSON 类型来保存用户画像数据，示意代码如下所示。</p><p>创建画像标签表。</p><div class="language-SQL line-numbers-mode" data-ext="SQL"><pre class="language-SQL"><code>create table `tb_tags`\n(\n`tag_id` int unsigned not null comment &#39;标签ID&#39;,\n`tag_name` varchar(20) not null comment &#39;标签名&#39;,\nprimary key (`tag_id`)\n) engine=innodb;\n\ninsert into `tb_tags` (`tag_id`, `tag_name`) \nvalues\n    (1, &#39;70后&#39;),\n    (2, &#39;80后&#39;),\n    (3, &#39;90后&#39;),\n    (4, &#39;00后&#39;),\n    (5, &#39;爱运动&#39;),\n    (6, &#39;高学历&#39;),\n    (7, &#39;小资&#39;),\n    (8, &#39;有房&#39;),\n    (9, &#39;有车&#39;),\n    (10, &#39;爱看电影&#39;),\n    (11, &#39;爱网购&#39;),\n    (12, &#39;常点外卖&#39;);\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为用户打标签。</p><div class="language-SQL line-numbers-mode" data-ext="SQL"><pre class="language-SQL"><code>create table `tb_users_tags`\n(\n`user_id` bigint unsigned not null comment &#39;用户ID&#39;,\n`user_tags` json not null comment &#39;用户标签&#39;\n) engine=innodb;\n\ninsert into `tb_users_tags` values \n    (1, &#39;[2, 6, 8, 10]&#39;),\n    (2, &#39;[3, 10, 12]&#39;),\n    (3, &#39;[3, 8, 9, 11]&#39;);\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来，我们通过一组查询来了解 JSON 类型的巧妙之处。</p><ol><li><p>查询爱看电影（有<code>10</code>这个标签）的用户ID。</p><div class="language-SQL line-numbers-mode" data-ext="SQL"><pre class="language-SQL"><code>select `user_id` from `tb_users_tags` where 10 member of (`user_tags`-&gt;&#39;$&#39;);\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>查询爱看电影（有<code>10</code>这个标签）的80后（有<code>2</code>这个标签）用户ID。</p><div class="language-SQL line-numbers-mode" data-ext="SQL"><pre class="language-SQL"><code>select `user_id` from `tb_users_tags` where json_contains(`user_tags`-&gt;&#39;$&#39;, &#39;[2, 10]&#39;);\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>查询爱看电影或80后或90后的用户ID。</p><div class="language-SQL line-numbers-mode" data-ext="SQL"><pre class="language-SQL"><code>select `user_id` from `tb_users_tags` where json_overlaps(user_tags-&gt;&#39;$&#39;, &#39;[2, 3, 10]&#39;);\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ol><blockquote><p><strong>说明</strong>：上面的查询用到了<code>member of</code>谓词和两个 JSON 函数，<code>json_contains</code>可以检查 JSON 数组是否包含了指定的元素，而<code>json_overlaps</code>可以检查 JSON 数组是否与指定的数组有重叠部分。</p></blockquote><h4 id="窗口函数" tabindex="-1"><a class="header-anchor" href="#窗口函数" aria-hidden="true">#</a> 窗口函数</h4><p>MySQL 从8.0开始支持窗口函数，大多数商业数据库和一些开源数据库早已提供了对窗口函数的支持，有的也将其称之为 OLAP（联机分析和处理）函数，听名字就知道跟统计和分析相关。为了帮助大家理解窗口函数，我们先说说窗口的概念。</p><p>窗口可以理解为记录的集合，窗口函数也就是在满足某种条件的记录集合上执行的特殊函数，对于每条记录都要在此窗口内执行函数。窗口函数和我们上面讲到的聚合函数比较容易混淆，二者的区别主要在于聚合函数是将多条记录聚合为一条记录，窗口函数是每条记录都会执行，执行后记录条数不会变。窗口函数不仅仅是几个函数，它是一套完整的语法，函数只是该语法的一部分，基本语法如下所示：</p><div class="language-SQL line-numbers-mode" data-ext="SQL"><pre class="language-SQL"><code>&lt;窗口函数&gt; over (partition by &lt;用于分组的列名&gt; order by &lt;用户排序的列名&gt;)\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面语法中，窗口函数的位置可以放以下两种函数：</p><ol><li>专用窗口函数，包括：<code>lead</code>、<code>lag</code>、<code>first_value</code>、<code>last_value</code>、<code>rank</code>、<code>dense_rank</code>和<code>row_number</code>等。</li><li>聚合函数，包括：<code>sum</code>、<code>avg</code>、<code>max</code>、<code>min</code>和<code>count</code>等。</li></ol><p>下面为大家举几个使用窗口函数的简单例子，我们直接使用上一课创建的 hrs 数据库。</p><p>例子1：查询按月薪从高到低排在第4到第6名的员工的姓名和月薪。</p><div class="language-SQL line-numbers-mode" data-ext="SQL"><pre class="language-SQL"><code>select * from (\n	select \n		`ename`, `sal`,\n		row_number() over (order by `sal` desc) as `rank`\n	from `tb_emp`\n) `temp` where `rank` between 4 and 6;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',33),u=n("code",null,"row_number()",-1),v=n("code",null,"rank()",-1),m=n("code",null,"dense_rank()",-1),b={href:"https://zhuanlan.zhihu.com/p/92654574",target:"_blank",rel:"noopener noreferrer"},g=i('<div class="language-SQL line-numbers-mode" data-ext="SQL"><pre class="language-SQL"><code>select `rank`, `ename`, `sal` from (\n       select @a:=@a+1 as `rank`, `ename`, `sal` \n      from `tb_emp`, (select @a:=0) as t1 order by `sal` desc\n) as `temp` where `rank` between 4 and 6;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>例子2：查询每个部门月薪最高的两名的员工的姓名和部门名称。</p><div class="language-SQL line-numbers-mode" data-ext="SQL"><pre class="language-SQL"><code>select `ename`, `sal`, `dname` \nfrom (\n    select \n        `ename`, `sal`, `dno`,\n        rank() over (partition by `dno` order by `sal` desc) as `rank`\n    from `tb_emp`\n) as `temp` natural join `tb_dept` where `rank`&lt;=2;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明：在MySQL 8以前的版本，我们可以通过下面的方式来完成类似的操作。</p><div class="language-SQL line-numbers-mode" data-ext="SQL"><pre class="language-SQL"><code>select `ename`, `sal`, `dname` from `tb_emp` as `t1` \nnatural join `tb_dept` \nwhere (\n   select count(*) from `tb_emp` as `t2` \n   where `t1`.`dno`=`t2`.`dno` and `t2`.`sal`&gt;`t1`.`sal` \n)&lt;2 order by `dno` asc, `sal` desc;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',5);function p(_,S){const s=a("ExternalLinkIcon");return l(),r("div",null,[o,n("p",null,[e("上面使用的函数"),u,e("可以为每条记录生成一个行号，在实际工作中可以根据需要将其替换为"),v,e("或"),m,e("函数，三者的区别可以参考官方文档或阅读"),n("a",b,[e("《通俗易懂的学会：SQL窗口函数》"),t(s)]),e("进行了解。在MySQL 8以前的版本，我们可以通过下面的方式来完成类似的操作。")]),g])}const L=d(c,[["render",p],["__file","第47课.MySQL新特性.html.vue"]]);export{L as default};
