<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="https://vuepress-theme-hope-docs-demo.netlify.app/atom.xsl"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN">
  <id>https://vuepress-theme-hope-docs-demo.netlify.app/</id>
  <title>暴走の海鸽</title>
  <subtitle>暴走の海鸽</subtitle>
  <icon>https://vuepress-theme-hope-docs-demo.netlify.app/logo.svg</icon>
  <updated>2023-08-18T10:46:30.390Z</updated>
  <generator>vuepress-plugin-feed2</generator>
  <link rel="self" href="https://vuepress-theme-hope-docs-demo.netlify.app/atom.xml"/>
  <link rel="alternate" href="https://vuepress-theme-hope-docs-demo.netlify.app/"/>
  <entry>
    <title type="text">【python】多线程详解</title>
    <id>https://vuepress-theme-hope-docs-demo.netlify.app/docs/python/python%E5%9F%BA%E7%A1%80/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3.html</id>
    <link href="https://vuepress-theme-hope-docs-demo.netlify.app/docs/python/python%E5%9F%BA%E7%A1%80/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3.html"/>
    <updated>2023-07-08T07:26:09.000Z</updated>
    <summary type="html"><![CDATA[<h2> 为什么要使用多线程？</h2>
<p>使用多线程，可以同时进行多项任务，可以使用户界面更友好，还可以后台执行某些用时长的任务，同时具有易于通信的优点。（对于GIL以及Python多线程对于效率的影响讨论可看知乎<a href="https://www.zhihu.com/question/23474039" target="_blank" rel="noopener noreferrer">为什么有人说 Python 的多线程是鸡肋呢？ - 知乎 (zhihu.com)</a>）</p>
<p>python3中多线程的实现使用了threading模块，它允许同一进程中运行多个线程。</p>]]></summary>
    <content type="html"><![CDATA[<h2> 为什么要使用多线程？</h2>
<p>使用多线程，可以同时进行多项任务，可以使用户界面更友好，还可以后台执行某些用时长的任务，同时具有易于通信的优点。（对于GIL以及Python多线程对于效率的影响讨论可看知乎<a href="https://www.zhihu.com/question/23474039" target="_blank" rel="noopener noreferrer">为什么有人说 Python 的多线程是鸡肋呢？ - 知乎 (zhihu.com)</a>）</p>
<p>python3中多线程的实现使用了threading模块，它允许同一进程中运行多个线程。</p>
<h3> 如何创建和执行一个线程</h3>
<p>一般我们有两种方法来创建线程，一种是以某个函数来作为起点，另一种是继承Thread类。</p>
<h4> 方法一</h4>
<p>获取一个Thread对象，构造参数中target是起点函数，<code>注意不要加括号</code>。假如起点函数有参数，则可以通过args输入元组参数或者kwargs输入字典参数。</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果为：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 方法二</h4>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果为：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 正式介绍threading模块</h2>
<blockquote>
<p><a href="https://docs.python.org/3/library/threading.html" target="_blank" rel="noopener noreferrer">https://docs.python.org/3/library/threading.html</a></p>
</blockquote>
<p>关于线程信息的函数：</p>
<ul>
<li><code>threading.active_count()</code>：返回当前存活的Thread对象数量。</li>
<li><code>threading.current_thread()</code>：返回当前线程的Thread对象。</li>
<li><code>threading.enumerate()</code>：列表形式返回所有存活的Thread对象。</li>
<li><code>threading.main_thread()</code>：返回主Thread对象。</li>
</ul>
<p>Thread对象的方法及属性：</p>
<ul>
<li><code>Thread.name</code>：线程的名字，没有语义，可以相同名称。</li>
<li><code>Thread.ident</code>：线程标识符，非零整数。</li>
<li><code>Thread.Daemon</code>：是否为守护线程。</li>
<li><code>Thread.is_alive()</code>：是否存活。</li>
<li><code>Thread.start()</code>：开始线程活动。若多次调用抛出RuntimeError。</li>
<li><code>Thread.run()</code>：用来重载的，</li>
<li><code>Thread.join(timeout=None)</code>：等待直到线程正常或异常结束。尚未开始抛出RuntimeError</li>
<li><code>Thread(group=None, target=None, name=None, args=(), kwargs={}, *, deamon=None)</code>：构造函数。</li>
</ul>
<h3> 守护线程 Daemon</h3>
<p>在Python 3中，守护线程（daemon thread）是一种特殊的线程，它在程序运行时在后台运行，不会阻止程序的退出。当主线程退出时，守护线程也不会自动退出，而不需要等待它执行完毕。</p>
<h4> 方法一</h4>
<p>在创建线程对象时，可以通过设置<code>daemon</code>属性为<code>True</code>来创建守护线程，例如：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果为：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例中，我们创建了一个守护线程<code>worker()</code>，并将<code>daemon</code>属性设置为<code>True</code>。在主线程中，我们执行了一些操作，并休眠5秒钟。由于守护线程的存在，即使主线程已经结束，守护线程仍会在后台运行。</p>
<h4> 方法二</h4>
<p>设置守护线程用Thread.setDaemon(bool)</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果为：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>守护线程的作用在于，当我们需要在程序运行时执行一些后台任务，但是不想让这些任务阻止程序的正常退出时，可以使用守护线程。<br>
例如，在一个Web应用程序中，我们可能需要启动一个守护线程来定期清理缓存或者执行一些后台任务。</p>
</blockquote>
<p>需要注意的是，守护线程无法完全控制其执行过程，因此不能用于一些必须在程序退出之前完成的任务。同时，守护线程不能访问一些主线程资源，例如共享内存或者打开的文件，因为这些资源可能会在主线程结束时被释放。</p>
<h3> 让主线程等待子线程结束 join</h3>
<p>假如要让主线程等子线程结束，那么可以使用Thread.join()方法。</p>
<p>当调用线程对象的<code>join()</code>方法时，主线程将被阻塞，直到该线程执行完成或者超时。</p>
<p>以下是一个简单的示例：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果为：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例中，我们创建了一个子线程<code>worker()</code>，并使用<code>start()</code>方法启动线程。在主线程中，我们调用了线程对象的<code>join()</code>方法，让主线程等待子线程执行完毕。在子线程执行完毕后，主线程继续执行。</p>
<p>需要注意的是，<code>join()</code>方法还可以设置超时时间，以避免无限期等待线程的执行。例如：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果为：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例中，我们设置了<code>join()</code>方法的超时时间为3秒钟，即使子线程没有执行完成，主线程也会在3秒钟后继续执行。</p>
<h2> 线程共享资源可能引起什么问题？</h2>
<p>在线程编程中，多个线程可能同时访问和修改同一个共享资源，例如全局变量、共享内存、文件等。如果没有进行适当的同步操作，就可能会引发以下问题：</p>
<p><strong>竞态条件（Race Condition）</strong>：当多个线程同时访问和修改同一个共享资源时，就可能会发生竞态条件。这种情况下，由于线程执行顺序的不确定性，可能会导致资源被错误地读取或写入，从而引发程序的错误或崩溃。</p>
<p><strong>死锁（Deadlock）</strong>：当多个线程都在等待另一个线程释放某个资源时，就可能会发生死锁。这种情况下，程序会永久地阻塞在这个状态下，无法继续执行。</p>
<p><strong>活锁（Livelock）</strong>：多个线程相互协作，但是由于某些原因无法前进，导致它们不断重试，最终导致系统陷入死循环。活锁是一种比死锁更难以诊断和解决的问题。</p>
<p>为了避免以上问题，我们可以使用线程同步机制来保护共享资源的访问。</p>
<p>例如，可以使用<code>锁（Lock）</code>、<code>信号量（Semaphore）</code>、<code>条件变量（Condition）</code>等机制来限制同时访问共享资源的线程数量，从而避免竞态条件。同时，也可以使用一些算法和策略来避免死锁和活锁等问题的发生。</p>
<p>下面是一些具体的例子，说明在多线程程序中共享资源可能引发的问题：</p>
<h4> 竞态条件</h4>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果为：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在这个例子中，我们创建了3个线程来执行<code>sum_one()</code>函数，这个三个线程会分别对全局变量<code>x</code>都进行<code>加1000000</code>操作。由于多个线程同时访问和修改<code>x</code>变量，就会产生竞态条件，导致<code>x</code>的最终值可能小于3000000。</p>
<h4> 死锁</h4>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们创建了两个线程<code>worker1()</code>和<code>worker2()</code>，它们都需要同时获取<code>lock1</code>和<code>lock2</code>两个锁来执行操作。由于<code>worker1()</code>先获取<code>lock1</code>，然后尝试获取<code>lock2</code>，而<code>worker2()</code>先获取<code>lock2</code>，然后尝试获取<code>lock1</code>，就可能会产生死锁的情况。</p>
<h4> 活锁</h4>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果为:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们创建了两个账户<code>acc1</code>和<code>acc2</code>，并创建了两个线程<code>worker1()</code>和<code>worker2()</code>，它们不断地在这两个账户之间转账。</p>
<p>由于<code>transfer()</code>方法中需要获取锁来修改账户余额，但是两个线程的执行顺序可能会导致它们同时等待对方释放锁，从而无法前进，最终导致系统陷入活锁的状态。</p>
<p>具体来说，假设<code>worker1()</code>执行了<code>acc1.transfer(acc2, 100)</code>，然后进入了<code>transfer()</code>方法中的<code>if self.withdraw(amount)</code>分支，在等待<code>acc1</code>的锁。</p>
<p>此时，<code>worker2()</code>执行了<code>acc2.transfer(acc1, 100)</code>，然后也进入了<code>transfer()</code>方法中的<code>if self.withdraw(amount)</code>分支，在等待<code>acc2</code>的锁。由于<code>acc1</code>和<code>acc2</code>之间的转账是相互依赖的，因此这两个线程无法前进，会一直重试，最终导致系统陷入活锁的状态。</p>
<h2> 多线程的锁机制</h2>
<p>在Python3中，锁机制是一种线程同步机制，它用于协调多个线程的并发访问共享资源，以避免竞态条件的发生。</p>
<p>Python 3中的多线程锁机制主要是通过<code>threading</code>模块中的<code>Lock</code>、<code>RLock</code>和<code>Semaphore</code>等类来实现的。</p>
<p><code>Lock</code>类是最基本的锁，它提供了两个基本方法<code>acquire()</code>和<code>release()</code>，用于获取锁和释放锁。当一个线程调用<code>acquire()</code>方法时，如果该锁没有被其他线程获取，则该线程获取到该锁并进入临界区，否则该线程就会被阻塞，直到该锁被其他线程释放为止。</p>
<p><code>RLock</code>类是可重入锁，它允许同一个线程多次获取该锁，每次获取都必须有对应的释放操作。如果一个线程已经获取到该锁，它可以再次获取该锁而不被阻塞，这就是可重入的特性。<code>RLock</code>类提供了<code>acquire()</code>和<code>release()</code>方法，与<code>Lock</code>类相同。</p>
<p><code>Semaphore</code>类是信号量，它与锁类似，但可以允许多个线程同时访问某个资源，而不是像锁一样只允许一个线程访问。它提供了<code>acquire()</code>和<code>release()</code>方法，用于获取和释放资源。</p>
<p>下面是一个使用<code>Lock</code>类的示例代码：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的代码中，我们定义了一个全局变量<code>counter</code>和一个<code>Lock</code>对象<code>lock</code>。<code>increment()</code>函数用于在循环中对<code>counter</code>进行100000次加1操作，而在每次加1之前，我们首先获取<code>lock</code>，加1操作完成之后再释放<code>lock</code>。这样保证了多个线程同时对<code>counter</code>进行操作时，不会产生竞争条件。</p>
<blockquote>
<p>另外，还需要注意到，对于每个获取锁的线程，一定要记得在合适的地方释放锁，否则就会出现死锁的情况。</p>
</blockquote>
<p>在多线程环境中，多个线程可能同时访问某个共享资源，这可能导致竞态条件的发生，从而导致程序出现不可预测的结果。为了避免这种情况的发生，我们可以使用锁机制来控制对共享资源的访问。在使用锁机制时，需要注意以下几点：</p>
<ol>
<li>锁是一种互斥机制，即同一时刻只能有一个线程持有锁，其他线程必须等待该线程释放锁后才能继续执行。</li>
<li>在访问共享资源前，线程需要先获取锁。如果锁已经被其他线程持有，则线程会被阻塞，直到其他线程释放锁。</li>
<li>在访问共享资源后，线程需要释放锁，以便其他线程可以获取锁并访问共享资源。</li>
<li>在使用锁时，需要保证所有线程都使用同一个锁对象。</li>
</ol>
<p>锁机制可以用于解决多线程程序中的竞态条件、死锁和活锁等问题。</p>
<h4> 下面我们分别通过例子来说明锁是如何解决这些问题的。</h4>
<p><strong>竞态条件</strong></p>
<p>竞态条件指的是多个线程对共享资源的竞争，导致结果的正确性取决于线程的执行顺序。</p>
<p>比如，在一个多线程程序中，多个线程同时对同一个变量进行加减操作，结果可能取决于每个线程的执行顺序，这就是一个典型的竞态条件。</p>
<p>通过使用锁，可以保证在任何时刻只有一个线程能够访问共享资源，从而避免竞态条件的出现。下面的例子演示了如何使用锁来解决竞态条件：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果为：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在这个例子中，多个线程对 Counter 对象的 count 属性进行加 1 操作，这可能会导致竞态条件。</p>
<p>为了避免这种情况，我们使用了一个锁，通过 with self.lock 来获取锁，这样在任何时刻只有一个线程能够修改 count 属性。</p>
<p>这样，我们就避免了竞态条件的出现。</p>
<p><strong>死锁</strong></p>
<p>死锁是指两个或多个线程在等待彼此释放资源，从而形成僵局的情况。为了解决死锁问题，可以使用锁机制来协调线程对共享资源的访问。具体来说，当一个线程获得锁时，其他线程必须等待该线程释放锁之后才能访问共享资源，从而避免多个线程同时访问同一个共享资源而产生死锁。</p>
<p>例如，考虑一个简单的场景，其中有两个线程，分别需要获取两个共享资源才能继续执行。假设这两个线程在获取资源时的顺序不同，可能会出现死锁的情况。</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码中，<code>thread_a</code>和<code>thread_b</code>分别获取<code>resource_a</code>和<code>resource_b</code>，但是它们的获取顺序不同。因此，如果这两个线程同时运行，就有可能发生死锁的情况，导致程序卡住。</p>
<p>为了避免死锁，可以使用锁机制。修改上述代码，如下所示：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例中，每个线程都按照相同的顺序获取锁，这样就避免了死锁的情况。</p>
<p><strong>活锁</strong></p>
<p>活锁是多线程程序中的一种常见问题，它是指线程在尝试协调其操作时一直重试，但最终没有达到进展的状态。一个常见的例子是两个线程互相等待对方释放其持有的资源。</p>
<p>使用锁是解决活锁问题的一种常见方式。当线程需要访问共享资源时，必须获得相应的锁。如果锁已经被其他线程持有，线程将阻塞直到获得锁为止。这样，当多个线程尝试同时访问同一共享资源时，只有一个线程能够获取锁，其他线程将被阻塞。</p>
<p>下面是一个使用锁解决活锁问题的例子。假设有两个线程A和B，它们需要同时访问两个共享资源x和y，但由于资源x和y的访问顺序不同，线程A需要先获得x再获得y，而线程B需要先获得y再获得x。如果两个线程尝试同时获取它们需要的资源，就会出现活锁问题。</p>
<p>使用锁可以解决这个问题。假设每个线程都先获取x的锁，然后再获取y的锁，这样就可以保证每个线程都按照相同的顺序获取资源，避免了死锁和活锁的问题。</p>
<p>下面是使用锁解决活锁问题的代码示例：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，每个线程都使用相同的锁顺序来获取资源x和y，这样就避免了活锁的问题。</p>
<blockquote>
<p>使用锁可能导致执行速度慢，但是保证了线程安全<br>
无论是Lock还是RLock，acquire和release都要成对出现</p>
</blockquote>
<h2> 多线程的通信</h2>
<p>Python3 中多线程之间的通信方式有以下几种：</p>
<h4> 队列</h4>
<p>在 Python 3 中，可以使用队列（Queue）实现多线程之间的通信。队列是线程安全的数据结构，可以实现线程之间的同步和协作，避免竞争条件和死锁问题。</p>
<p>Python 内置了 Queue 模块，提供了队列数据结构，它可以用于实现多线程之间的安全通信。可以使用队列的 put() 方法往队列中添加元素，使用 get() 方法从队列中取出元素。</p>
<p>Queue模块提供了以下几个类：</p>
<ul>
<li>Queue：基本队列，实现FIFO（先进先出）的算法。</li>
<li>LifoQueue：与Queue类似，但是实现了LIFO（后进先出）的算法。</li>
<li>PriorityQueue：队列中的每个元素都有一个优先级，每次弹出优先级最高的元素。</li>
<li>SimpleQueue：类似于Queue，但是没有任务协作的功能，也就是说，不能在进程之间使用。</li>
</ul>
<p>Queue类中最常用的方法包括：</p>
<ul>
<li>put(item[, block[, timeout]])：将一个item放入队列，如果队列已满，block为True则阻塞，直到队列未满或超时；block为False时，则抛出queue.Full异常。</li>
<li>get([block[, timeout]])：从队列中取出并返回一个item，如果队列为空，block为True则阻塞，直到队列不为空或超时；block为False时，则抛出queue.Empty异常。</li>
<li>task_done()：通知队列，一个先前放入队列的任务已经完成。</li>
<li>join()：阻塞主线程，直到队列中所有的任务都被处理完。</li>
</ul>
<p>下面举一个简单的例子：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的例子中，我们创建了一个生产者线程和一个消费者线程。生产者线程负责向队列中添加数据，消费者线程负责从队列中取出数据。生产者线程每隔一秒钟向队列中添加一个字符串，消费者线程每隔半秒钟从队列中取出一个字符串。为了避免消费者线程在队列为空时陷入死循环，我们在队列的末尾放置了一个 None 值，当消费者线程取出该值时，就会退出循环。</p>
<h4> 事件（Event）</h4>
<p>事件是一种同步对象，可以用于多线程之间的通信，常用于控制线程的执行顺序。可以使用事件的 set() 方法设置事件，使用 wait() 方法等待事件被设置，使用 clear() 方法清除事件。</p>
<p>以下是一个使用事件实现多线程间通信的示例代码：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果为：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>该代码创建了两个线程，它们都等待事件被设置，当事件被设置后，它们才开始执行。在主线程中，先休眠了 3 秒钟，然后设置了事件，从而唤醒了两个线程。在实际应用中，事件可以用于控制线程的执行顺序，或者实现线程之间的协作。</p>
<h4> 锁（Lock）</h4>
<p>使用锁可以实现多线程间的通信，可以通过共享变量和锁的机制来实现线程间的同步和互斥。具体来说，一个线程需要访问共享变量时，首先需要获得锁，然后读取或修改共享变量的值，完成操作后再释放锁，以便其他线程访问共享变量。</p>
<ul>
<li>下面是一个简单的示例代码，其中两个线程共享一个变量 <code>counter</code>，通过锁的机制来实现对该变量的互斥访问。</li>
</ul>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果为：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在这个例子中，<code>CounterThread</code> 是一个继承自 <code>threading.Thread</code> 的线程类，它有一个成员变量 <code>lock</code>，用于控制对共享变量 <code>counter</code> 的访问。在 <code>run</code> 方法中，线程会循环执行一定次数的加操作，每次操作前会获取锁并对 <code>counter</code> 做加一操作，完成后再释放锁。在主线程中创建了 10 个 <code>CounterThread</code> 线程，并启动它们进行计数操作。在所有线程都执行完毕后，打印出 <code>counter</code> 的最终值。</p>
<p>使用锁可以确保多个线程对共享变量的访问是互斥的，从而避免竞态条件和数据损坏等问题。但是，使用锁也可能会导致性能问题和死锁等问题，因此需要谨慎使用，并根据实际情况选择合适的同步机制。</p>
<ul>
<li>或者</li>
</ul>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例中，我们创建了一个 <code>Counter</code> 类，其中包含一个整数 <code>value</code> 和一个锁对象 <code>lock</code>。 <code>increment</code> 方法使用 <code>with</code> 语句获取锁并增加 <code>value</code> 的值。</p>
<p>我们还创建了 10 个线程，每个线程都会调用 <code>worker</code> 函数。这个函数会循环 10000 次调用 <code>increment</code> 方法来增加 <code>value</code> 的值。</p>
<p>由于每个线程都会获取锁来访问共享资源，因此只有一个线程可以访问 <code>increment</code> 方法，避免了多个线程同时修改 <code>value</code> 的值，从而确保了线程安全。最终的输出结果应该是<code>100000</code>，即<code>10</code>个线程分别增加了<code>10000</code>次。</p>
<h4> 条件变量（Condition）实现多线程间的通信</h4>
<p>条件变量（Condition）是Python多线程编程中常用的线程间通信机制之一，它可以用于线程间的通信和同步，提供了一个线程等待另一个线程通知其发生了某个事件的方法。</p>
<p>下面是一个使用条件变量实现多线程间通信的示例代码：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例代码中，生产者线程通过<code>cond.notify()</code>方法通知消费者线程，消费者线程通过<code>cond.wait()</code>方法等待生产者线程的通知。条件变量<code>cond</code>用于实现线程之间的同步和通信，生产者线程和消费者线程在共享同一把锁的情况下，通过<code>with self.cond:</code>语句获取条件变量的锁并进入临界区，确保线程安全。</p>
<h4> 信号量（Semaphore）实现多线程间的通信</h4>
<p>信号量（Semaphore）是一种用于控制并发访问共享资源的同步原语。它是一种计数器，用于控制多个线程对共享资源的访问。信号量维护一个计数器，初始值为一个非负整数，每当一个线程访问共享资源时，计数器减1；当计数器为0时，所有试图访问共享资源的线程都会被阻塞，直到某个线程释放了共享资源，此时计数器加1，被阻塞的线程才有机会继续执行。</p>
<p>在 Python 中，我们可以使用 <code>threading.Semaphore</code> 类来创建信号量对象。该类的构造函数接受一个整数作为参数，表示初始计数器的值。<code>Semaphore</code> 类有两个方法，<code>acquire()</code> 和 <code>release()</code>，分别用于获取和释放信号量。</p>
<p>以下是使用信号量实现的简单示例代码：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例代码中，有一个生产者线程和两个消费者线程。生产者线程向共享缓冲区中添加数据，而消费者线程从缓冲区中获取数据。为了避免竞争条件，我们使用了信号量。</p>
<p>在生产者线程中，当信号量可用时，它会获取信号量并添加数据到缓冲区中，然后释放信号量。在消费者线程中，当信号量可用时，它会获取信号量并从缓冲区中获取数据，然后释放信号量。</p>
<p>通过使用信号量，我们可以确保生产者和消费者线程之间的同步，从而避免了竞争条件和死锁问题。</p>
<h4> 管道（Pipe）</h4>
<p>在 Python3 中，可以使用 <code>multiprocessing</code> 模块中的 <code>Pipe</code> 类来实现多进程间的通信，也可以用 <code>multiprocessing.connection</code> 模块来创建多进程间的通信通道。下面的例子是用 <code>Pipe</code> 类来实现多线程间的通信：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们创建了两个线程，一个生产者线程和一个消费者线程。它们之间共享一个管道（<code>Pipe</code>），其中生产者将数据写入管道，而消费者从管道中读取数据。当生产者完成其工作后，它会关闭管道以通知消费者停止运行。</p>
<p>需要注意的是，在 <code>Pipe</code> 中，发送和接收操作是阻塞的。因此，在发送或接收数据时，如果没有可用的空间或数据，线程将被阻塞，直到有数据可用或空间可用。</p>
<h2> 定时器Timer</h2>
<p>定时器（Timer）是Python中的一个线程类，它可以在一定时间之后调用指定的函数或方法。Timer是继承自Thread类的，因此可以像Thread一样启动、停止和等待它。</p>
<p>定时器的构造函数如下：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>其中，<code>interval</code>表示定时器的时间间隔（秒），<code>function</code>表示定时器超时后要调用的函数或方法。<code>args</code>和<code>kwargs</code>是传递给函数或方法的参数。</p>
<p>下面是一个使用定时器的例子：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个程序中，我们创建了一个定时器<code>t</code>，它会在5秒后调用<code>hello</code>函数，并启动定时器。程序将在启动定时器后立即继续执行，而定时器则在后台等待5秒，然后调用<code>hello</code>函数。</p>
<p>如果我们想要停止定时器，可以使用<code>cancel()</code>方法：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>需要注意的是，如果定时器已经超时并且在调用函数之前被取消，那么函数将不会被调用。因此，需要在调用<code>cancel()</code>方法之前等待定时器超时。</p>
<h2> python3线程池</h2>
<h4> concurrent.futures实现多线程</h4>
<p>Python 3中的线程池是一种常见的多线程编程模型，可以提高多线程程序的性能和可维护性。在Python 3中，线程池可以通过标准库中的<code>concurrent.futures</code>模块来实现。</p>
<p><code>concurrent.futures</code>模块定义了两个类：<code>ThreadPoolExecutor</code>和<code>ProcessPoolExecutor</code>。这两个类都实现了Python 3中的执行器(Executor)接口，提供了一种方便的方式来异步执行函数或方法，并返回其结果。</p>
<p><strong>Exectuor</strong>&nbsp;提供了如下常用方法：</p>
<ul>
<li><code>submit(fn, *args, **kwargs)</code>：将 fn 函数提交给线程池。*args 代表传给 fn 函数的参数，*kwargs 代表以关键字参数的形式为 fn 函数传入参数。</li>
<li><code>map(func, *iterables, timeout=None, chunksize=1)</code>：该函数类似于全局函数&nbsp;<code>map(func, *iterables)</code>，只是该函数将会启动多个线程，以异步方式立即对 iterables 执行 map 处理。超时抛出TimeoutError错误。返回每个函数的结果，<strong>注意不是返回future</strong>。</li>
<li><code>shutdown(wait=True)</code>：关闭线程池。关闭之后线程池不再接受新任务，但会将之前提交的任务完成。</li>
</ul>
<p>程序将task函数submit给线程池后，会返回一个Future对象，Future主要用来获取task的返回值。</p>
<p><strong>Future</strong>&nbsp;提供了如下方法：</p>
<ul>
<li><code>cancel()</code>：取消该 Future 代表的线程任务。如果该任务正在执行，不可取消，则该方法返回 False；否则，程序会取消该任务，并返回 True。</li>
<li><code>cancelled()</code>：返回 Future 代表的线程任务是否被成功取消。</li>
<li><code>running()</code>：如果该 Future 代表的线程任务正在执行、不可被取消，该方法返回 True。</li>
<li><code>done()</code>：如果该 Funture 代表的线程任务被成功取消或执行完成，则该方法返回 True。</li>
<li><code>result(timeout=None)</code>：获取该 Future 代表的线程任务最后返回的结果。如果 Future 代表的线程任务还未完成，该方法将会阻塞当前线程，其中 timeout 参数指定最多阻塞多少秒。超时抛出TimeoutError，取消抛出CancelledError。</li>
<li><code>exception(timeout=None)</code>：获取该 Future 代表的线程任务所引发的异常。如果该任务成功完成，没有异常，则该方法返回 None。</li>
<li><code>add_done_callback(fn)</code>：为该 Future 代表的线程任务注册一个“回调函数”，当该任务成功完成时，程序会自动触发该 fn 函数，参数是future。</li>
</ul>
<p>使用线程池来执行线程任务的步骤如下：</p>
<ol>
<li>调用 ThreadPoolExecutor 类的构造器创建一个线程池。</li>
<li>定义一个普通函数作为线程任务。</li>
<li>调用 ThreadPoolExecutor 对象的 submit() 方法来提交线程任务。</li>
<li>当不想提交任何任务时，调用 ThreadPoolExecutor 对象的 shutdown() 方法来关闭线程池。</li>
</ol>
<p><code>ThreadPoolExecutor</code>是一个线程池执行器，可以用来执行异步任务，它管理着一个线程池，其中包含若干个线程。当一个任务被提交给执行器时，执行器会将其分配给一个线程来执行。当线程池中的所有线程都在执行任务时，新提交的任务会被放入队列中，直到有可用的线程为止。</p>
<p>以下是一个使用<code>ThreadPoolExecutor</code>的简单示例：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们创建了一个线程池执行器，并指定了最大线程数为3。然后我们循环提交5个任务给执行器，每个任务都是一个<code>worker</code>函数，并传入不同的参数。由于我们设置了最大线程数为3，所以只会有3个任务同时被执行，另外2个任务会在之后的某个时间点被执行。</p>
<p>执行结果会存储在<code>Future</code>对象中，我们可以通过<code>as_completed()</code>方法获取任务的执行结果。如果任务执行过程中发生了异常，<code>result()</code>方法会抛出相应的异常。否则，它会返回任务的执行结果。</p>
<p><code>ThreadPoolExecutor</code>还有其他一些有用的方法，例如<code>shutdown()</code>方法可以等待所有已提交的任务执行完毕并关闭线程池。</p>
<p>总之，Python 3中的线程池提供了一种方便的方式来执行异步任务，可以大大提高多线程程序的性能和可维护性。</p>
<h4> 使用线程池的好处和场景</h4>
<p>使用线程池的优点是可以避免线程的频繁创建和销毁，从而提高线程的利用率，减少系统的开销。因此，当需要频繁执行短时间的任务时，可以考虑使用线程池。例如：</p>
<ol>
<li>网络服务器：在服务器端接收客户端请求后，可以使用线程池来处理客户端请求，以提高服务器的并发性能。</li>
<li>图像处理：在图像处理过程中，需要频繁启动和停止线程来处理每个像素点的计算，使用线程池可以减少线程的创建和销毁，提高处理效率。</li>
<li>数据库连接池：在数据库操作中，需要频繁创建和销毁数据库连接，使用线程池可以减少这种开销，提高数据库操作的效率。</li>
</ol>
<p>总之，当需要频繁执行短时间的任务时，可以考虑使用线程池来优化程序性能。</p>
<blockquote>
<p>喜欢这篇文章的话，就点个关注吧，或者关注一下我的公众号『<strong>海哥python</strong>』也可以，会持续分享高质量Python文章，以及其它内容。</p>
</blockquote>
<figure><img src="/wechat/haige_wechat_public.png" alt="海哥python 官方公众号" tabindex="0" loading="lazy"><figcaption>海哥python 官方公众号</figcaption></figure>
]]></content>
    <published>2023-07-08T07:26:09.000Z</published>
  </entry>
  <entry>
    <title type="text">【python】装饰器详解</title>
    <id>https://vuepress-theme-hope-docs-demo.netlify.app/docs/python/python%E5%9F%BA%E7%A1%80/Python%E8%A3%85%E9%A5%B0%E5%99%A8%E8%AF%A6%E8%A7%A3.html</id>
    <link href="https://vuepress-theme-hope-docs-demo.netlify.app/docs/python/python%E5%9F%BA%E7%A1%80/Python%E8%A3%85%E9%A5%B0%E5%99%A8%E8%AF%A6%E8%A7%A3.html"/>
    <updated>2023-07-08T07:26:09.000Z</updated>
    <summary type="html"><![CDATA[<h2> 前言</h2>
<p>本文将带你学习装饰器在 Python 中的工作原理，如果在函数和类中使用装饰器，如何利用装饰器避免代码重复（<code>DRY 原则，Don’t Repeat Yourself</code> ）。</p>
<h2> 装饰器是什么</h2>
<p>装饰器一直以来都是 Python 中很有用、很经典的一个 feature，在工程中的应用也十分广泛，比如日志、缓存等等的任务都会用到。然而，在平常工作生活中，我发现不少人，尤其是初学者，常常因为其相对复杂的表示，对装饰器望而生畏，认为它“<code>too fancy to learn</code>”，实际并不如此。</p>]]></summary>
    <content type="html"><![CDATA[<h2> 前言</h2>
<p>本文将带你学习装饰器在 Python 中的工作原理，如果在函数和类中使用装饰器，如何利用装饰器避免代码重复（<code>DRY 原则，Don’t Repeat Yourself</code> ）。</p>
<h2> 装饰器是什么</h2>
<p>装饰器一直以来都是 Python 中很有用、很经典的一个 feature，在工程中的应用也十分广泛，比如日志、缓存等等的任务都会用到。然而，在平常工作生活中，我发现不少人，尤其是初学者，常常因为其相对复杂的表示，对装饰器望而生畏，认为它“<code>too fancy to learn</code>”，实际并不如此。</p>
<p>你可能已经和装饰器打过不少交道了。在做面向对象编程时，我们就经常会用到 <code>@staticmethod</code> 和 <code>@classmethod</code> 两个内置装饰器。此外，如果你接触过 <a href="https://click.palletsprojects.com/en/7.x/" target="_blank" rel="noopener noreferrer">click</a> 模块，就更不会对装饰器感到陌生。click 最为人所称道的参数定义接口 <code>@click.option(...)</code> 就是利用装饰器实现的。</p>
<p>装饰器在 Python中是一个非常强大和有用的工具，因为它允许程序员修改函数或类的行为。装饰器允许我们包装另一个函数，<code>以扩展包装函数的行为</code>，而无需修改基础函数定义。这也被称为元编程，因为程序本身在程序运行时会尝试修改自身的另一部分。</p>
<p>装饰器是<code>语法糖</code>： 在代码中利用更简洁流畅的语法实现更为复杂的功能。</p>
<blockquote>
<p>万能公式：注意理解语法糖的等价形式</p>
</blockquote>
<p>我们知道，Python中一切皆对象。这意味着<code>Python中的函数可以用作参数或作为参数传递</code>。一等函数的属性：</p>
<ul>
<li>函数是 Object 类型的实例。</li>
<li>可以将函数存储在变量中。</li>
</ul>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>可以将该函数作为参数传递给另一个函数。</li>
</ul>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>我们可以在函数里定义函数，也就是函数的嵌套。</li>
</ul>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>函数的返回值也可以是函数对象（闭包）。</li>
</ul>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>可以将它们存储在数据结构中，例如哈希表，列表等。</li>
</ul>
<h2> 装饰器语法糖</h2>
<p>如果你接触<code>Python</code>有一段时间了的话，想必你对<code>@</code>符号一定不陌生了，没错<code>@</code>符号就是装饰器的语法糖。它放在一个函数开始定义的地方，它就像一顶帽子一样戴在这个函数的头上。和这个函数绑定在一起。在我们调用这个函数的时候，第一件事并不是执行这个函数，而是将这个函数做为参数传入它头顶上这顶帽子，这顶帽子我们称之为<code>装饰函数</code>或<code>装饰器</code>。</p>
<p>装饰器的使用方法很固定：</p>
<ul>
<li>先定义一个装饰函数（帽子）（也可以用类、偏函数实现）</li>
<li>再定义你的业务函数、或者类（人）</li>
<li>最后把这顶帽子戴在这个人头上</li>
</ul>
<h2> 函数装饰器</h2>
<p><code>decorator必须是一个“可被调用（callable）的对象或属性描述符（Descriptors）</code>。</p>
<p>~理解描述符是深入理解 Python 的关键，因为它们是许多功能的基础，包括函数、方法、属性、类方法、静态方法和对超类的引用。这个暂不做过多赘述！~</p>
<blockquote>
<p><code>输入是函数，输出也是函数~</code></p>
</blockquote>
<h3> 装饰不带参数的函数</h3>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>更优雅的语法糖<code>@</code>表示，大大提高函数的重复利用和程序的可读性：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果为：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 装饰带一个参数的函数</h3>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>等价于：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果为：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 装饰带不定长参数的函数</h3>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 装饰器带参数</h3>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果为：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 原函数还是原函数吗？</h3>
<p>我们试着打印出 greet() 函数的一些元信息：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了解决这个问题，我们通常使用内置的装饰器<code>@functools.wrap</code>，它会帮助保留原函数的元信息（也就是将原函数的元信息，拷贝到对应的装饰器函数里）。</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 类装饰器</h2>
<p><code>定义一个类装饰器，装饰函数，默认调用__call__方法</code></p>
<h3> 类装饰器-本身无参数</h3>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>类装饰器本身无参数时等价于<code>example = Count(example)</code></p>
</blockquote>
<p>输出结果为：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 如何定义带参数的类装饰器</h3>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>等价于：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果为：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 描述符与装饰器</h3>
<p>还有一类装饰器比较特殊，比如基于python描述符实现的<code>property</code>。</p>
<blockquote>
<p>在Python中，属性描述符可以用作装饰器，是因为描述符对象可以通过实现 <code>__get__()</code>、<code>__set__()</code> 和 <code>__delete__()</code> 方法来拦截对属性的访问和操作。<br>
<a href="https://docs.python.org/3/reference/datamodel.html#descriptors" target="_blank" rel="noopener noreferrer">https://docs.python.org/3/reference/datamodel.html#descriptors</a><br>
<a href="https://docs.python.org/3/howto/descriptor.html#descriptorhowto" target="_blank" rel="noopener noreferrer">https://docs.python.org/3/howto/descriptor.html#descriptorhowto</a></p>
</blockquote>
<p><code>关于描述符，这里不赘述</code>。基于描述符，我们也可以实现自定义的property:</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 装饰类的装饰器</h2>
<p>在Python中，装饰类的装饰器是一种特殊类型的函数，它用于修改或增强类的行为。装饰器可以在不修改原始类定义的情况下，通过将类传递给装饰器函数来对其进行装饰。</p>
<p>通常情况下，装饰类的装饰器是一个接受类作为参数的函数，并返回一个新的类或修改原始类的函数。这个装饰器函数可以在类定义之前使用<code>@</code>符号应用到类上。</p>
<blockquote>
<p><code>输入是类，输出也是类~</code></p>
</blockquote>
<h3> 如何定义装饰类的装饰器</h3>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果为：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上述示例中，<code>timer_decorator</code>装饰器接收一个类作为参数，并返回一个继承自原始类的新类<code>TimerClass</code>。<code>TimerClass</code>中重写了<code>__getattribute__</code>方法，在调用类的方法时，会计算方法的执行时间并进行打印。</p>
<h3> 巧用functools.partial</h3>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> django示例</h3>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>等价于<code>MyView = require_login（MyView）</code></p>
</blockquote>
<h3> objprint示例</h3>
<p><code>一个有意思的python三方模块，使用装饰器打印object</code></p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出为：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 使用 wrapt 模块编写更扁平的装饰器</h2>
<p>在写装饰器的过程中，你有没有碰到过什么不爽的事情？这里列举两个可能使你特别难受的点：</p>
<blockquote>
<ol>
<li><code>实现带参数的装饰器时，层层嵌套的函数代码特别难写、难读</code></li>
<li><code>因为函数和类方法的不同，为前者写的装饰器经常没法直接套用在后者上</code></li>
</ol>
</blockquote>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>@provide_number</code> 装饰器功能看上去很不错，但它有着我在前面提到的两个问题：<strong><code>嵌套层级深、无法在类方法上使用</code></strong>。如果直接用它去装饰类方法，会出现下面的情况：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>Foo</code> 类实例中的 <code>print_random_number</code> 方法将会输出类实例 <code>self</code> ，而不是我们期望的随机数 <code>num</code>。</p>
<p>之所以会出现这个结果，是因为类方法 <em>（method）</em> 和函数 <em>（function）</em> 二者在工作机制上有着细微不同。如果要修复这个问题，<code>provider_number</code> 装饰器在修改类方法的位置参数时，必须聪明的跳过藏在 <code>*args</code> 里面的类实例 <code>self</code> 变量，才能正确的将 <code>num</code> 作为第一个参数注入。</p>
<p>这时，就应该是 <a href="https://pypi.org/project/wrapt/" target="_blank" rel="noopener noreferrer">wrapt</a> 模块闪亮登场的时候了。<code>wrapt</code> 模块是一个专门帮助你编写装饰器的工具库。利用它，我们可以非常方便的改造 <code>provide_number</code> 装饰器，完美解决“<code>嵌套层级深</code>”和“<code>无法通用</code>”两个问题，</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 使用wrapt写一个不带参数的装饰器</h3>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 使用wrapt写一个带参数的装饰器</h3>
<p>如果您希望实现一个接受参数的装饰器，请将装饰器的定义包装在函数闭包中。应用装饰器时提供给外部函数的任何参数都将在调用包装函数时可供内部包装器使用。</p>
<blockquote>
<p>函数签名是固定的，必须是(wrapped, instance, args, kwargs)</p>
</blockquote>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 使用wrapt的装饰器嵌套</h3>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用 <code>wrapt</code> 模块编写的装饰器，相比原来拥有下面这些优势：</p>
<ul>
<li>嵌套层级少：使用 <code>@wrapt.decorator</code> 可以将两层嵌套减少为一层</li>
<li>更简单：处理位置与关键字参数时，可以忽略类实例等特殊情况</li>
<li>更灵活：针对 <code>instance</code> 值进行条件判断后，更容易让装饰器变得通用</li>
</ul>
<h2> 装饰器的嵌套</h2>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>它的执行顺序从里到外，所以上面的语句也等效于下面这行代码：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果为：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 多装饰器的执行顺序</h2>
<p>说到Python装饰器的执行顺序，有很多半吊子张口就来：</p>
<blockquote>
<p>靠近函数名的装饰器先执行，远离函数名的装饰器后执行。</p>
</blockquote>
<p><code>这种说法是不准确的</code>。</p>
<h3> 举个栗子</h3>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这里，你可以先花几秒钟思考下这段代码的输出结果是什么呢？也许会出乎一些人的预料！！</p>
<p><code>结果揭晓</code>：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其实，只要我们套用万能替代公式，是不难得出正确的答案的。直接上代码：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>装饰器里面的代码中，<code>wrapper</code>闭包外面的代码确实是内层装饰器先执行，外层装饰器后执行。这部分是在带上<code>@</code>帽子之后就执行了，而并非是在调用的时候。这个从等价形式也可以得出结论，因为带帽的时候其实已经做过某些调用了，这个你可以细品。</p>
</blockquote>
<p>重点是闭包<code>wrapper</code>内部的代码的执行顺序。通过等价公式不难得出，最后执行的<code>func</code>已经不是原来的<code>func</code>函数，而是<code>decorator_outer(func)</code>。</p>
<ul>
<li>所以执行<code>func()</code>其实是执行了<code>decorator_outer(func)()</code>，因此先打印了<code>外层装饰器，函数运行之前</code>;</li>
<li>然后执行<code>decorator_outer</code>装饰器<code>wrapper</code>闭包里的<code>func</code>函数，而<code>decorator_outer</code>装饰器<code>wrapper</code>闭包里的<code>func</code>函数此时是<code>func = decorator_inner(func)</code>;</li>
<li>所以紧接着打印了<code>内层装饰器，函数运行之前</code>—&gt;<code>我是函数本身</code>—&gt;<code>内层装饰器，函数运行之后</code>—&gt;<code>外层装饰器，函数运行之后</code>。</li>
</ul>
<blockquote>
<p>所以，当我们说多个装饰器堆叠的时候，哪个装饰器的代码先运行时，不能一概而论说内层装饰器的代码先运行。</p>
</blockquote>
<p>闭包<code>wrapper</code>内部的代码执行逻辑：</p>
<ol>
<li>外层装饰器先执行，但只执行了一部分，执行到调用<code>func()</code></li>
<li>内层装饰器开始执行</li>
<li>内层装饰器执行完</li>
<li>外层装饰器执行完</li>
</ol>
<blockquote>
<p>重点：需要搞清楚<code>函数和函数调用</code>的区别，注意：函数是可以当成返回值的</p>
</blockquote>
<p>在实际应用的场景中，当我们采用上面的方式写了两个装饰方法比如先验证有没有登录<code>@login_required</code>，再验证权限够不够时<code>@permision_allowed</code>时，我们采用下面的顺序来装饰函数:</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 装饰器应用场景示例</h2>
<h3> 缓存装饰器</h3>
<p>下面的缓存装饰器可以帮助你避免重复计算，以提高代码的性能。</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 输入合法性检查</h3>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 日志记录</h3>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 身份认证</h3>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 单例模式</h3>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上述示例中，<code>singleton</code> 装饰器用于创建单例类。装饰器包装了 <code>Logger</code> 类，确保只有一个 <code>Logger</code> 的实例存在。</p>
<h3> 策略模式</h3>
<p>电商领域有个功能明显可以使用“策略”模式，即根据客户的属性或订单中的商品计算折扣。<br>
假如一个网店制定了下述折扣规则。</p>
<ul>
<li>有<code>1000或以上积分</code>的顾客，每个订单享<code>5%</code> 折扣。</li>
<li>同一订单中，单个商品的数量达到<code>20个或以上</code>，享<code>10%</code>折扣。</li>
<li>订单中的不同商品达到<code>10个或以上</code>，享<code>7%</code>折扣。</li>
</ul>
<p>简单起见，我们<code>假定一个订单一次只能享用一个折扣</code>。</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 总结</h2>
<p>所谓的装饰器，其实就是通过装饰器函数，来修改原函数的一些功能，使得原函数不需要修改。</p>
<p>一切<code>callable</code>的对象都可以被用来实现装饰器。</p>
<p><code>wrapt</code>模块很有用，用它可以帮助我们用更简单的代码写出复杂装饰器。</p>
<p>装饰器的应用场景其实很常见，我们常见的判断用户是否登录(token校验的判断)、用户是否有访问权限很多都是使用装饰器来判断的，在DRF(django restframework)中的<code>@api_view</code>、<code>@permission_classes</code>。</p>
<p>合理使用装饰器，往往能极大地提高程序的可读性以及运行效率。</p>
<p>每当你对装饰器感到迷茫的时候，可以将装饰器用其等价形式理解。</p>
<h2> 参考</h2>
<blockquote>
<p><a href="https://mp.weixin.qq.com/s/PXu-68puFUpxzJRqUHJwBw" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/PXu-68puFUpxzJRqUHJwBw</a><br>
<a href="https://segmentfault.com/a/1190000007837364" target="_blank" rel="noopener noreferrer">https://segmentfault.com/a/1190000007837364</a><br>
<a href="https://github.com/piglei/one-python-craftsman/blob/master/zh_CN/8-tips-on-decorators.md" target="_blank" rel="noopener noreferrer">https://github.com/piglei/one-python-craftsman/blob/master/zh_CN/8-tips-on-decorators.md</a></p>
</blockquote>
<blockquote>
<p>喜欢这篇文章的话，就点个关注吧，或者关注一下我的公众号『<strong>海哥python</strong>』也可以，会持续分享高质量Python文章，以及其它内容。<br>
<img src="/wechat/haige_wechat_public.png" alt="海哥python 官方公众号" loading="lazy"></p>
</blockquote>
]]></content>
    <published>2023-07-08T07:26:09.000Z</published>
  </entry>
</feed>